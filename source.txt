extern crate clap;

use byteorder::{NetworkEndian, WriteBytesExt}; 
use attest_client::ClientRaContext;
use ra_common::tcp::tcp_connect;
use std::time::Duration;
use std::io::Write;
use clap::App;

fn main() {
    let matches = App::new("attest-client")
                .version("1.0")
                .author("simplelin. ")
                .about("Do remote attestation")
                .args_from_usage(
                    "-e   --enclave=[String] 'Sets IP and Port for enclave,such as: \"127.0.0.1:7777\"'
                    -s   --server=[String] 'Sets IP and Port for service provide,such as: \"192.168.1.1:1234\"'
                    -n   --number=[u8]     'Serial number for the enclave that will send quote to client,\"0-255\".such as:0' ")
                .get_matches();
    let enclave  = matches.value_of("enclave").unwrap_or("127.0.0.1:7777");
    let service  = matches.value_of("server").unwrap_or("127.0.0.1:1234");
    let number  = matches.value_of("number").unwrap_or("0");//.as_bytes();
    let number  = number.parse::<u8>().expect("the input value is invalid,that should be a id and type is \"u8\"");
    let timeout = Duration::from_secs(5);
    let mut enclave_stream =
        tcp_connect(enclave, timeout).expect("Client: Enclave connection failed");
    eprintln!("Client: connected to enclave {:?}.", enclave);

    let mut sp_stream =
        tcp_connect(service, timeout).expect("Client: SP connection failed");
    eprintln!("Client: connected to SP {:?}.", service);
    sp_stream.write_u8(number).unwrap();
    let context = ClientRaContext::init().unwrap();
    context
        .do_attestation(&mut enclave_stream, &mut sp_stream)
        .unwrap();
    let msg = "127.0.0.1:3333";
    sp_stream.write_u32::<NetworkEndian>(msg.len() as u32).unwrap();
    //write!(&mut sp_stream, "{}", msg).unwrap();
    sp_stream.write(msg.as_bytes()).unwrap();
    eprintln!("Client: done!");
}
use crate::error::ClientRaError;
use crate::ClientRaResult;
use aesm_client::{AesmClient, QuoteInfo};
use ra_common::msg::{Gid, Quote, RaMsg0, RaMsg1, RaMsg2, RaMsg3, RaMsg4};
use sgx_crypto::cmac::MacTag;
use sgx_crypto::key_exchange::DHKEPublicKey;
use sgx_isa::Report;
use std::convert::TryInto;
use std::io::{Read, Write};
use std::mem::size_of;

pub struct ClientRaContext {
    pub ctx_aesm_client: AesmClient,
    pub quote_info: QuoteInfo,
    pub g_a: Option<DHKEPublicKey>,
}

impl ClientRaContext {
    pub fn init() -> ClientRaResult<Self> {
        let ctx_aesm_client = AesmClient::new();
        let quote_info = ctx_aesm_client.init_quote()?;
        Ok(Self {
            ctx_aesm_client,
            quote_info,
            g_a: None,
        })
    }

    pub fn do_attestation(
        mut self,
        mut enclave_stream: &mut (impl Read + Write),
        mut sp_stream: &mut (impl Read + Write),
    ) -> ClientRaResult<()> {
        let msg0 = self.get_extended_epid_group_id();
        if cfg!(feature = "verbose") {
            eprintln!("MSG0 generated");
        }

        bincode::serialize_into(&mut sp_stream, &msg0)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG0 sent");
        }

        let msg1 = self.get_msg_1(enclave_stream);
        if cfg!(feature = "verbose") {
            eprintln!("MSG1 generated");
        }

        bincode::serialize_into(&mut sp_stream, &msg1)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG1 sent");
        }

        let msg2: RaMsg2 = bincode::deserialize_from(&mut sp_stream)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG2 received");
        }

        let msg3 = self.process_msg_2(msg2, enclave_stream)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG3 generated");
        }

        bincode::serialize_into(&mut sp_stream, &msg3)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG3 sent");
        }

        let msg4: RaMsg4 = bincode::deserialize_from(&mut sp_stream)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG4 received");
        }

        bincode::serialize_into(&mut enclave_stream, &msg4).unwrap();

        if !msg4.is_enclave_trusted {
            return Err(ClientRaError::EnclaveNotTrusted);
        }
        match msg4.is_pse_manifest_trusted {
            Some(t) => {
                if !t {
                    return Err(ClientRaError::PseNotTrusted);
                }
            }
            None => {}
        }
        Ok(())
    }

    /// ExGID = 0 means IAS will be used for remote attestation. This function only
    /// returns 0 for now.
    pub fn get_extended_epid_group_id(&self) -> RaMsg0 {
        RaMsg0 { exgid: 0 }
    }

    pub fn get_msg_1(&mut self, enclave_stream: &mut (impl Read + Write)) -> RaMsg1 {
        let g_a: DHKEPublicKey = bincode::deserialize_from(enclave_stream).unwrap();
        let gid: Gid = self.quote_info.gid().try_into().unwrap();
        self.g_a = Some(g_a.clone());
        RaMsg1 { gid, g_a }
    }

    pub fn process_msg_2(
        &mut self,
        msg2: RaMsg2,
        mut enclave_stream: &mut (impl Read + Write),
    ) -> ClientRaResult<RaMsg3> {
        bincode::serialize_into(&mut enclave_stream, &msg2).unwrap();

        let sig_rl = match msg2.sig_rl {
            Some(sig_rl) => sig_rl.to_owned(),
            None => Vec::with_capacity(0),
        };
        let spid = (&msg2.spid[..]).to_owned();

        // Get a Quote and send it to enclave to sign
        let quote = Self::get_quote(&self.ctx_aesm_client, spid, sig_rl, enclave_stream)?;

        // Read MAC for msg3 from enclave
        let mut mac = [0u8; size_of::<MacTag>()];
        enclave_stream.read_exact(&mut mac).unwrap();

        Ok(RaMsg3 {
            g_a: self.g_a.take().unwrap(),
            mac,
            ps_sec_prop: None,
            quote,
        })
    }

    /// Get a Quote and send it to enclave to sign
    pub fn get_quote(
        aesm_client: &AesmClient,
        spid: Vec<u8>,
        sig_rl: Vec<u8>,
        enclave_stream: &mut (impl Read + Write),
    ) -> ClientRaResult<Quote> {
        let quote_info = aesm_client.init_quote()?;

        // Get report for local attestation with QE from enclave
        enclave_stream.write_all(quote_info.target_info()).unwrap();
        let mut report = vec![0u8; Report::UNPADDED_SIZE];
        enclave_stream.read_exact(&mut report[..]).unwrap();

        // Get a quote and QE report from QE and send them to enclave
        let _quote = aesm_client.get_quote(&quote_info, report, spid, sig_rl)?;
        enclave_stream.write_all(_quote.quote()).unwrap();
        enclave_stream.write_all(_quote.qe_report()).unwrap();

        let mut quote = [0u8; size_of::<Quote>()];
        quote.copy_from_slice(_quote.quote());
        Ok(quote)
    }
}
mod context;
mod error;

pub use crate::context::*;
pub use crate::error::*;

pub type ClientRaResult<T> = Result<T, ClientRaError>;
#[derive(Debug)]
pub enum ClientRaError {
    IO(std::boxed::Box<bincode::ErrorKind>),
    Aesm(aesm_client::Error),
    EnclaveNotTrusted,
    PseNotTrusted,
}

impl std::convert::From<aesm_client::Error> for ClientRaError {
    fn from(e: aesm_client::Error) -> Self {
        Self::Aesm(e)
    }
}

impl std::convert::From<std::boxed::Box<bincode::ErrorKind>> for ClientRaError {
    fn from(e: std::boxed::Box<bincode::ErrorKind>) -> Self {
        Self::IO(e)
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

extern crate byteorder;
extern crate mbedtls;
extern crate ndarray;
extern crate rand;
extern crate tvm_graph_rt;

use byteorder::{NetworkEndian, WriteBytesExt};
use std::net::TcpListener;
//use std::io::Write;
use mbedtls::pk::Pk;
// use mbedtls::rng::CtrDrbg;
use mbedtls::ssl::config::{Endpoint, Preset, Transport};
use mbedtls::ssl::{Config, Context};
use mbedtls::x509::Certificate;
use ra_enclave::tls_enclave::attestation;
use sgx_crypto::random::Rng;
use ra_enclave::context::EnclaveRaContext;
use std::convert::TryInto;
use sgx_crypto::keys;

use serde_json::Value;

use std::{
    convert::TryFrom as _,
    sync::Arc,
    io::{BufReader, Read, Write},
    // thread,
    time::{SystemTime, UNIX_EPOCH},
};
//use ndarray::{Array, Array4};

fn timestamp() -> i64 {
    let start = SystemTime::now();
    let since_the_epoch = start
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards");
    let ms = since_the_epoch.as_secs() as i64 * 1000i64
        + (since_the_epoch.subsec_nanos() as f64 / 1_000_000.0) as i64;
    ms
}

fn main() {
    // let mut thread_vec = vec![];
    // let handle = thread::spawn(move || {
    println!("Attestation start ...");
    let config = include_str!(concat!(env!("PWD"), "/config"));
    let config: Value = serde_json::from_str(config).unwrap();
    let client_address = config["client_address"].as_str().unwrap();
    let sp_address = config["sp_address"].as_str().unwrap();
    let mut enclave_racontext = attestation(client_address, sp_address, keep_message).unwrap();
    println!("Attestation end!");
    println!("do tvm start ...");
    do_tvm(&mut enclave_racontext);
    println!("do tvm end!");
    // });
    
    // thread_vec.push(handle);
    // let handle = thread::spawn(move || {
    //     do_tvm();
    // });
    // thread_vec.push(handle);
    // for handle in thread_vec {
    //     // Wait for the thread to finish. Returns a result.
    //     let _ = handle.join().unwrap();
    // }
}

pub fn keep_message(session: BufReader<mbedtls::ssl::Context>) {
    let mut sess = session;
    let msg = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque non placerat risus, et lobortis quam. Mauris velit lorem, elementum id neque a, aliquet tempus turpis. Nam eu congue urna, in semper quam. Ut tristique gravida nunc nec feugiat. Proin tincidunt massa a arcu volutpat, sagittis dignissim velit convallis. Cras ac finibus lorem, nec congue felis. Pellentesque fermentum vitae ipsum sed gravida. Nulla consectetur sit amet erat a pellentesque. Donec non velit sem. Sed eu metus felis. Nullam efficitur consequat ante, ut commodo nisi pharetra consequat. Ut accumsan eget ligula laoreet dictum. Maecenas tristique porta convallis. Suspendisse tempor sodales velit, ac luctus urna varius eu. Ut ultrices urna vestibulum vestibulum euismod. Vivamus eu sapien urna.";
    sess.get_mut().write_u32::<NetworkEndian>(msg.len() as u32).unwrap();
    write!(&mut sess.get_mut(), "{}", msg).unwrap();
}

pub fn do_tvm(racontext: &mut EnclaveRaContext) {
    let config = include_str!(concat!(env!("PWD"), "/config"));
    let config: Value = serde_json::from_str(config).unwrap();
    let server_address = config["server_address"].as_str().unwrap();
    //let client_address = config[3];
    let syslib = tvm_graph_rt::SystemLibModule::default();
    let graph_json = include_str!(concat!(env!("OUT_DIR"), "/graph.json"));
    let params_bytes = include_bytes!(concat!(env!("OUT_DIR"), "/params.bin"));
    let params = tvm_graph_rt::load_param_dict(params_bytes).unwrap();

    let graph = tvm_graph_rt::Graph::try_from(graph_json).unwrap();
    let mut exec = tvm_graph_rt::GraphExecutor::new(graph, &syslib).unwrap();
    exec.load_params(params);
    let listener = TcpListener::bind(server_address).unwrap();
    println!("TVM run: listening at {}", server_address);
    for stream in listener.incoming() {
        let mut stream = stream.unwrap();

        //to verify the quote and private key
        let signer_key = &mut racontext.signer_key;
        //read rand data from user
        let mut rand_data = vec![0u8; 64];
        let mut rng =Rng::new();
        stream.read_exact(&mut rand_data).unwrap();
        let sign_data = signer_key.ecdsa_sign(& rand_data,&mut rng).expect("Error when signing the user rang data!");        
        stream.write_u32::<NetworkEndian>(sign_data.len().try_into().unwrap()).unwrap();
        stream.write_all(racontext.quote.as_ref()).unwrap();
        stream.write_all(sign_data.as_ref()).unwrap();
        
        let mut verify_data = [0u8; 4];
        stream.read_exact(&mut verify_data).unwrap();
        if verify_data != [1u8;4]{
            eprintln!("an error occured when user verify the quote and sign!");
            continue;
        }
        let mut verify_data = [0u8; 4];
        stream.read_exact(&mut verify_data).unwrap();
        continue;
        let mut config = Config::new(Endpoint::Server, Transport::Stream, Preset::Default);
        let rng = Rng::new();
        config.set_rng(Arc::new(rng.inner));

        let cert = Arc::new(Certificate::from_pem_multiple(keys::PEM_CERT).unwrap());
        let key = Arc::new(Pk::from_private_key(keys::PEM_KEY, None).unwrap());
        config.push_cert(cert, key).unwrap();

        let rc_config = Arc::new(config);
        let mut ctx = Context::new(rc_config);
        ctx.establish(stream, None).unwrap();
        let mut server_session = BufReader::new(ctx);
        println!("TVM run: a new user is coming ...");
        if let Err(_) = server_session.read(
            exec.get_input("input")
                .unwrap()
                .data()
                .view()
                .as_mut_slice(),
        ) {
            continue;
        }
        let ts1 = timestamp();
        println!("TimeStamp: {}", ts1);
        let sy_time = SystemTime::now();
        exec.run();
        let duration = SystemTime::now()
            .duration_since(sy_time)
            .unwrap()
            .as_micros();
        server_session
            .get_mut()
            .write(exec.get_output(0).unwrap().data().as_slice())
            .unwrap();
        println!(
            "output len: {:?}",
            exec.get_output(0).unwrap().data().as_slice().len()
        );
        println!("{:?}", duration);
        //only try once
        break;
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

use std::process::Command;

macro_rules! mf_dir {
    ($p:literal) => {
        concat!(env!("CARGO_MANIFEST_DIR"), $p)
    };
}

fn main() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let build_output = Command::new("python")
        .arg(mf_dir!("/src/build_model.py"))
        .arg(&out_dir)
        .env(
            "PYTHONPATH",
            concat!(env!("TVM_HOME"), "/python", ":", env!("PYTHONPATH")),
        )
        .output()
        .expect("Failed to build model");
    assert!(
        ["model.o", "graph.json", "params.bin"]
            .iter()
            .all(|f| { std::path::Path::new(&format!("{}/{}", out_dir, f)).exists() }),
        "Could not build tvm lib: \nSTDOUT:\n\n{}\n\nSTDERR\n\n{}",
        String::from_utf8(build_output.stdout).unwrap().trim(),
        String::from_utf8(build_output.stderr).unwrap().trim()
    );

    let sysroot_output = Command::new("rustc")
        .args(&["--print", "sysroot"])
        .output()
        .expect("Failed to get sysroot");
    let sysroot = String::from_utf8(sysroot_output.stdout).unwrap();
    let sysroot = sysroot.trim();
    let mut llvm_tools_path = std::path::PathBuf::from(&sysroot);
    llvm_tools_path.push("lib/rustlib/x86_64-unknown-linux-gnu/bin");

    Command::new("rustup")
        .args(&["component", "add", "llvm-tools-preview"])
        .output()
        .expect("failed to install llvm tools");

    std::process::Command::new(llvm_tools_path.join("llvm-objcopy"))
        .arg("--globalize-symbol=__tvm_module_startup")
        .arg("--remove-section=.ctors")
        .arg(&format!("{}/model.o", out_dir))
        .output()
        .expect("gould not gloablize startup function");

    std::process::Command::new(llvm_tools_path.join("llvm-ar"))
        .arg("rcs")
        .arg(&format!("{}/libmodel.a", out_dir))
        .arg(&format!("{}/model.o", out_dir))
        .output()
        .expect("failed to package model archive");

    println!("cargo:rustc-link-lib=static=model");
    println!("cargo:rustc-link-search=native={}", out_dir);
}

mod sp_vkey;

use crate::sp_vkey::SP_VKEY_PEM;
use byteorder::{NetworkEndian, WriteBytesExt};
use ra_common::tcp::tcp_accept;
use ra_enclave::EnclaveRaContext;
use sgx_crypto::tls_psk::server;
use sgx_crypto::random::Rng;

fn main() {
    let client_addr = "localhost:7777";
    let mut client_stream = tcp_accept(&client_addr).expect("Enclave: Client connection failed");
    eprintln!("Enclave: connected to client.{:#?}", &client_addr);
    let context = EnclaveRaContext::init(SP_VKEY_PEM).unwrap();
    let (_signing_key, master_key) = context.do_attestation(&mut client_stream).unwrap();

    // talk to SP directly from now on
    let sp_addr = "localhost:1235";
    let mut sp_stream = tcp_accept(sp_addr).expect("Enclave: SP connection failed!");

    // establish TLS-PSK with SP; enclave is the server
    let mut psk_callback = server::callback(&master_key);
    let mut rng = Rng::new();
    let config = server::config(&mut rng, &mut psk_callback);
    let mut ctx = server::context(&config).unwrap();

    // begin secure communication
    let mut session = ctx.establish(&mut sp_stream, None).unwrap();
    let msg = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque non placerat risus, et lobortis quam. Mauris velit lorem, elementum id neque a, aliquet tempus turpis. Nam eu congue urna, in semper quam. Ut tristique gravida nunc nec feugiat. Proin tincidunt massa a arcu volutpat, sagittis dignissim velit convallis. Cras ac finibus lorem, nec congue felis. Pellentesque fermentum vitae ipsum sed gravida. Nulla consectetur sit amet erat a pellentesque. Donec non velit sem. Sed eu metus felis. Nullam efficitur consequat ante, ut commodo nisi pharetra consequat. Ut accumsan eget ligula laoreet dictum. Maecenas tristique porta convallis. Suspendisse tempor sodales velit, ac luctus urna varius eu. Ut ultrices urna vestibulum vestibulum euismod. Vivamus eu sapien urna.";
    session
        .write_u32::<NetworkEndian>(msg.len() as u32)
        .unwrap();
    write!(&mut session, "{}", msg).unwrap();
    eprintln!("Enclave: done!");
}
// 2048-bit RSASSA-PKCS1-v1_5 public key in PEM format
pub const SP_VKEY_PEM: &str = "\
-----BEGIN RSA PUBLIC KEY-----\n
MIIBCgKCAQEAvtc94gzwX0KeL1HJVh6XdHPXXA4PYE+ClqWUvxp5ts1/nLQzJVcy\
1SHMGaPUCr+IZJBeWapkFpgnJnw7YzdQ2kA8k6GiN/k8hlQMWXA2nE0LDeOHX8i7\
fc31lWy5nHdAXj7SfC/YV5RC/yhkJ2cYNMB15VPRHGQRukdVmvHUFunxwfkHq5mM\
xWWAWO5Km490NCWP7CqBH6ezGm5jUhzYT/n5y5EaVpqwKVE1uYA//L4dFSE7aDzD\
CDb50B9uqPaEyKHwc2taLiSPvQjDQE3BpKTDOqsVnojd9br1vYW/uemYnnlOJbSr\
L7pYuPODmV02by5r+7hgXFQkTADwFQBCmwIDAQAB\n\
-----END RSA PUBLIC KEY-----\
\0";
use crate::error::AttestationError;
use http::{HeaderMap, HeaderValue};
use regex::Regex;
use serde::Deserialize;
use serde_json::Value;
use sgx_crypto::certificate::X509Cert;

pub const CA_CERT_PEM: &str = "\
-----BEGIN CERTIFICATE-----\n\
MIIFSzCCA7OgAwIBAgIJANEHdl0yo7CUMA0GCSqGSIb3DQEBCwUAMH4xCzAJBgNV\
BAYTAlVTMQswCQYDVQQIDAJDQTEUMBIGA1UEBwwLU2FudGEgQ2xhcmExGjAYBgNV\
BAoMEUludGVsIENvcnBvcmF0aW9uMTAwLgYDVQQDDCdJbnRlbCBTR1ggQXR0ZXN0\
YXRpb24gUmVwb3J0IFNpZ25pbmcgQ0EwIBcNMTYxMTE0MTUzNzMxWhgPMjA0OTEy\
MzEyMzU5NTlaMH4xCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEUMBIGA1UEBwwL\
U2FudGEgQ2xhcmExGjAYBgNVBAoMEUludGVsIENvcnBvcmF0aW9uMTAwLgYDVQQD\
DCdJbnRlbCBTR1ggQXR0ZXN0YXRpb24gUmVwb3J0IFNpZ25pbmcgQ0EwggGiMA0G\
CSqGSIb3DQEBAQUAA4IBjwAwggGKAoIBgQCfPGR+tXc8u1EtJzLA10Feu1Wg+p7e\
LmSRmeaCHbkQ1TF3Nwl3RmpqXkeGzNLd69QUnWovYyVSndEMyYc3sHecGgfinEeh\
rgBJSEdsSJ9FpaFdesjsxqzGRa20PYdnnfWcCTvFoulpbFR4VBuXnnVLVzkUvlXT\
L/TAnd8nIZk0zZkFJ7P5LtePvykkar7LcSQO85wtcQe0R1Raf/sQ6wYKaKmFgCGe\
NpEJUmg4ktal4qgIAxk+QHUxQE42sxViN5mqglB0QJdUot/o9a/V/mMeH8KvOAiQ\
byinkNndn+Bgk5sSV5DFgF0DffVqmVMblt5p3jPtImzBIH0QQrXJq39AT8cRwP5H\
afuVeLHcDsRp6hol4P+ZFIhu8mmbI1u0hH3W/0C2BuYXB5PC+5izFFh/nP0lc2Lf\
6rELO9LZdnOhpL1ExFOq9H/B8tPQ84T3Sgb4nAifDabNt/zu6MmCGo5U8lwEFtGM\
RoOaX4AS+909x00lYnmtwsDVWv9vBiJCXRsCAwEAAaOByTCBxjBgBgNVHR8EWTBX\
MFWgU6BRhk9odHRwOi8vdHJ1c3RlZHNlcnZpY2VzLmludGVsLmNvbS9jb250ZW50\
L0NSTC9TR1gvQXR0ZXN0YXRpb25SZXBvcnRTaWduaW5nQ0EuY3JsMB0GA1UdDgQW\
BBR4Q3t2pn680K9+QjfrNXw7hwFRPDAfBgNVHSMEGDAWgBR4Q3t2pn680K9+Qjfr\
NXw7hwFRPDAOBgNVHQ8BAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADANBgkq\
hkiG9w0BAQsFAAOCAYEAeF8tYMXICvQqeXYQITkV2oLJsp6J4JAqJabHWxYJHGir\
IEqucRiJSSx+HjIJEUVaj8E0QjEud6Y5lNmXlcjqRXaCPOqK0eGRz6hi+ripMtPZ\
sFNaBwLQVV905SDjAzDzNIDnrcnXyB4gcDFCvwDFKKgLRjOB/WAqgscDUoGq5ZVi\
zLUzTqiQPmULAQaB9c6Oti6snEFJiCQ67JLyW/E83/frzCmO5Ru6WjU4tmsmy8Ra\
Ud4APK0wZTGtfPXU7w+IBdG5Ez0kE1qzxGQaL4gINJ1zMyleDnbuS8UicjJijvqA\
152Sq049ESDz+1rRGc2NVEqh1KaGXmtXvqxXcTB+Ljy5Bw2ke0v8iGngFBPqCTVB\
3op5KBG3RjbF6RRSzwzuWfL7QErNC8WEy5yDVARzTA5+xmBc388v9Dm21HGfcC8O\
DD+gT9sSpssq0ascmvH49MOgjt1yoysLtdCtJW/9FZpoOypaHx0R+mJTLwPXVMrv\
DaVzWh5aiEx+idkSGMnX\n\
-----END CERTIFICATE-----\
\0";

#[derive(Deserialize, Debug)]
pub struct AttestationResponse {
    // header
    pub advisory_url: Option<String>,
    pub advisory_ids: Option<String>,
    pub request_id: String,
    // body
    pub id: String,
    pub timestamp: String,
    pub version: u16,
    pub isv_enclave_quote_status: String,
    pub isv_enclave_quote_body: String,
    pub revocation_reason: Option<String>,
    pub pse_manifest_status: Option<String>,
    pub pse_manifest_hash: Option<String>,
    pub platform_info_blob: Option<String>,
    pub nonce: Option<String>,
    pub epid_pseudonym: Option<String>,
}

impl AttestationResponse {
    pub fn from_response(
        headers: &HeaderMap,
        body: Vec<u8>,
    ) -> Result<Self, AttestationError> {
        let root_ca_cert = X509Cert::new_from_pem(CA_CERT_PEM.as_bytes()).unwrap();
        Self::verify_response(&root_ca_cert, &headers, &body[..])?;

        let body: Value = {
            let body = String::from_utf8(body).unwrap();
            serde_json::from_str(&body).unwrap()
        };
        // if cfg!(feature = "verbose") {
        //     eprintln!("==============headers Result==============");
        //     eprintln!("{:#?}", headers);
        //     eprintln!("==============================================");
        //     eprintln!("==============body Result==============");
        //     eprintln!("{:#?}", body);
        //     eprintln!("==============================================");
        // }
        let h = |x: &HeaderValue| x.to_str().unwrap().to_owned();
        let b = |x: &str| x.to_owned();
        Ok(Self {
            // header
            advisory_ids: headers.get("advisory-ids").map(h),
            advisory_url: headers.get("advisory-url").map(h),
            request_id: headers.get("request-id").map(h).unwrap(),
            // body
            id: body["id"].as_str().unwrap().to_owned(),
            timestamp: body["timestamp"].as_str().unwrap().to_owned(),
            version: body["version"].as_u64().unwrap() as u16,
            isv_enclave_quote_status: body["isvEnclaveQuoteStatus"].as_str().unwrap().to_owned(),
            isv_enclave_quote_body: body["isvEnclaveQuoteBody"].as_str().unwrap().to_owned(),
            revocation_reason: body["revocationReason"].as_str().map(b),
            pse_manifest_status: body["pseManifestStatus"].as_str().map(b),
            pse_manifest_hash: body["pseManifestHash"].as_str().map(b),
            platform_info_blob: body["platformInfoBlob"].as_str().map(b),
            nonce: body["nonce"].as_str().map(b),
            epid_pseudonym: body["epidPseudonym"].as_str().map(b),
        })
    }

    fn verify_response(
        root_ca_cert: &X509Cert,
        headers: &HeaderMap,
        body: &[u8],
    ) -> Result<(), AttestationError> {
        // Split certificates
        let re = Regex::new(
            "(-----BEGIN .*-----\\n)\
                            ((([A-Za-z0-9+/]{4})*\
                              ([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)*\\n)+)\
                            (-----END .*-----)",
        )
        .unwrap();
        let (mut certificate, mut ca_certificate) = {
            let c = headers
                .get("x-iasreport-signing-certificate")
                .unwrap()
                .to_str()
                .unwrap();
            let c = percent_encoding::percent_decode_str(c)
                .decode_utf8()
                .unwrap();
            let c = re
                .find_iter(&c)
                .map(|m| m.as_str().to_owned())
                .collect::<Vec<String>>();
            let mut c_iter = c.into_iter();
            let mut certificate = c_iter.next().unwrap();
            certificate.push('\0');
            let certificate = X509Cert::new_from_pem(certificate.as_bytes()).unwrap();
            let mut ca_certificate = c_iter.next().unwrap();
            ca_certificate.push('\0');
            let ca_certificate = X509Cert::new_from_pem(ca_certificate.as_bytes()).unwrap();
            (certificate, ca_certificate)
        };

        // Check if the root certificate is the same as the SP-provided certificate
        if root_ca_cert != &ca_certificate {
            return Err(AttestationError::MismatchedIASRootCertificate);
        }

        // Check if the certificate is signed by root CA
        certificate
            .verify_this_certificate(&mut ca_certificate)
            .map_err(|_| AttestationError::InvalidIASCertificate)?;

        // Check if the signature is correct
        let signature = base64::decode(
            headers
                .get("x-iasreport-signature")
                .unwrap()
                .to_str()
                .unwrap(),
        )
        .unwrap();
        certificate
            .verify_signature(body, &signature[..])
            .map_err(|_| AttestationError::BadSignature)?;
        Ok(())
    }
}
use crate::error::EnclaveRaError;
use crate::context::EnclaveRaContext;
use sgx_crypto::random::Rng;
use sgx_crypto::tls_psk::server;
use sgx_crypto::signature::SigningKey;
use ra_common::tcp::tcp_accept;
use std::net::{TcpStream};
use std::collections::HashMap;
use std::io::{BufReader, Read, Write};
use serde::{Deserialize, Serialize};
use http::{HeaderMap, StatusCode};
use std::sync::Arc;
use mbedtls::ssl::Context;

pub const SP_VKEY_PEM: &str = "\
-----BEGIN RSA PUBLIC KEY-----\n
MIIBCgKCAQEAvtc94gzwX0KeL1HJVh6XdHPXXA4PYE+ClqWUvxp5ts1/nLQzJVcy\
1SHMGaPUCr+IZJBeWapkFpgnJnw7YzdQ2kA8k6GiN/k8hlQMWXA2nE0LDeOHX8i7\
fc31lWy5nHdAXj7SfC/YV5RC/yhkJ2cYNMB15VPRHGQRukdVmvHUFunxwfkHq5mM\
xWWAWO5Km490NCWP7CqBH6ezGm5jUhzYT/n5y5EaVpqwKVE1uYA//L4dFSE7aDzD\
CDb50B9uqPaEyKHwc2taLiSPvQjDQE3BpKTDOqsVnojd9br1vYW/uemYnnlOJbSr\
L7pYuPODmV02by5r+7hgXFQkTADwFQBCmwIDAQAB\n\
-----END RSA PUBLIC KEY-----\
\0";

#[derive(Serialize, Deserialize, Debug)]
pub struct HttpRespWrap{
    #[serde(with = "http_serde::header_map")] 
    pub map: HeaderMap,
    #[serde(with = "http_serde::status_code")] 
    pub statu: StatusCode,
}

pub fn attestation(client:&str, sp:&str, keep_message:fn(BufReader<Context>))->Result<EnclaveRaContext, EnclaveRaError>{
    let mut client_stream = tcp_accept(client).expect("Enclave: Client connection failed");
    eprintln!("Enclave: listening at:{:?}", client);
    let mut encontext = EnclaveRaContext::init(SP_VKEY_PEM).unwrap();
    let (_signing_key, master_key) = encontext.do_attestation(&mut client_stream).unwrap();

    // talk to SP directly from now on
    //let sp_port = 1235;
    let sp_stream = tcp_accept(sp).expect("Enclave: SP connection failed");
    // establish TLS-PSK with SP; enclave is the server
    let mut psk_callback = server::callback(&master_key);
    let rng = Rng::new();
    let config = server::config(rng, &mut psk_callback);
    let mut ctx = server::context(Arc::new(config));
    // begin secure communication
    ctx.establish(sp_stream, None).unwrap();
    eprintln!("Enclave: done!");
    let server_session = BufReader::new(ctx);
    keep_message(server_session);
    Ok(encontext)
}
pub fn attestation_get_report(client:&str, sp:&str, keep_message:fn(TcpStream, &mut HashMap<u8, (Vec<u8>, Vec<u8>)>), report: &mut HashMap<u8, (Vec<u8>, Vec<u8>)> )->Result<SigningKey, EnclaveRaError>{
    let mut client_stream = tcp_accept(client).expect("Enclave: Client connection failed");
    eprintln!("Enclave: connected to client.");
    let mut encontext = EnclaveRaContext::init(SP_VKEY_PEM).unwrap();
    let (_signing_key, _master_key) = encontext.do_attestation(&mut client_stream).unwrap();

    // talk to SP directly from now on
    //let sp_port = 1235;
    println!("wait for connect:");
    let sp_stream = tcp_accept(sp).expect("Enclave: SP connection failed");
    println!("wait for connect: done!");
    keep_message(sp_stream, report);
    Ok(encontext.signer_key)
}use crate::error::EnclaveRaError;
use crate::local_attestation;
use crate::EnclaveRaResult;
use ra_common::derive_secret_keys;
use ra_common::msg::{Quote, RaMsg2, RaMsg3, RaMsg4};
use sgx_crypto::cmac::{Cmac, MacTag};
use sgx_crypto::digest::sha256;
use sgx_crypto::key_exchange::OneWayAuthenticatedDHKE;
use sgx_crypto::random::Rng;
use sgx_crypto::signature::{VerificationKey, SigningKey};
use sgx_isa::{Report, Targetinfo};
use std::io::{Read, Write};
use std::mem::size_of;
use std::time::SystemTime;

pub struct EnclaveRaContext {
    pub key_exchange: Option<OneWayAuthenticatedDHKE>,
    pub sp_vkey: VerificationKey,
    pub signer_key: SigningKey,
    pub quote: Quote
}

impl EnclaveRaContext {
    pub fn init(sp_vkey_pem: &str) -> EnclaveRaResult<Self> {
        let mut rng = Rng::new();
        let mut signer_rng = Rng::new();
        let key_exchange = OneWayAuthenticatedDHKE::generate_keypair(&mut rng)?;
        let signer_key = SigningKey::generate_keypair(&mut signer_rng).expect("generate signing key pair failed!");
        Ok(Self {
            sp_vkey: VerificationKey::new(sp_vkey_pem.as_bytes())?,
            key_exchange: Some(key_exchange),
            signer_key,
            quote: [0u8;size_of::<Quote>()]
        })
    }

    pub fn do_attestation(
        &mut self,
        mut client_stream: &mut (impl Read + Write),
    ) -> EnclaveRaResult<(MacTag, MacTag)> {
        let (sk, mk) = self.process_msg_2(client_stream).unwrap();
        let msg4: RaMsg4 = bincode::deserialize_from(&mut client_stream).unwrap();
        if !msg4.is_enclave_trusted {
            return Err(EnclaveRaError::EnclaveNotTrusted);
        }
        match msg4.is_pse_manifest_trusted {
            Some(t) => {
                if !t {
                    return Err(EnclaveRaError::PseNotTrusted);
                }
            }
            None => {}
        }
        Ok((sk, mk))
    }

    // Return (signing key, master key)
    pub fn process_msg_2(
        &mut self,
        mut client_stream: &mut (impl Read + Write),
    ) -> EnclaveRaResult<(MacTag, MacTag)> {

        //generate the msg_1, send to sp enclave
        let g_a = self.key_exchange.as_ref().unwrap().get_public_key()?;
        bincode::serialize_into(&mut client_stream, &g_a).unwrap();

        let msg2: RaMsg2 = bincode::deserialize_from(&mut client_stream).unwrap();

        // Verify and derive KDK and then other secret keys
        let mut rng = Rng::new();
        let kdk = self
            .key_exchange
            .take()
            .unwrap()
            .verify_and_derive(&msg2.g_b, &msg2.sign_gb_ga, &mut self.sp_vkey, &mut rng)
            .unwrap();
        let mut kdk_cmac = Cmac::new(&kdk)?;
        let (smk, sk, mk, vk) = derive_secret_keys(&mut kdk_cmac)?;
        let mut smk = Cmac::new(&smk)?;

        // Verify MAC tag of MSG2
        msg2.verify_mac(&mut smk)?;

        // Obtain SHA-256(g_a || g_b || vk)
        let mut verification_msg = Vec::new();
        verification_msg.write_all(g_a.as_ref()).unwrap();
        verification_msg.write_all(&msg2.g_b).unwrap();
        verification_msg.write_all(&vk).unwrap();
        let verification_digest = sha256(&verification_msg[..])?;
        //add a ecdsa public key to report data for a sign
        let sy_time = SystemTime::now();
        let signer_public_key = self.signer_key.get_public_key()?;
        println!("public_key generation time: {:?}", SystemTime::now().duration_since(sy_time).unwrap().as_micros());
        let mut _report_data = [0u8; 64];
        (&mut _report_data[..(verification_digest.len())]).clone_from_slice(&verification_digest);
        
        //signer_public_key.len() ==33, so we need to copy to _report_data at (verification_digest.len()-1)
        (&mut _report_data[(verification_digest.len()-1)..]).clone_from_slice(&signer_public_key);
        // Obtain Quote
        let sy_time = SystemTime::now();
        self.get_quote(&_report_data[..], client_stream)?;
        println!("quote generation time: {:?}", SystemTime::now().duration_since(sy_time).unwrap().as_micros());
        // Send MAC for msg3 to client
        let msg3 = RaMsg3::new(&mut smk, g_a, None, self.quote)?;
        client_stream.write_all(&msg3.mac).unwrap();

        Ok((sk, mk))
    }

    /// Get quote from Quote Enclave. The length of report_data must be <= 64 bytes.
    pub fn get_quote(
        &mut self,
        report_data: &[u8],
        client_stream: &mut (impl Read + Write),
    ) -> EnclaveRaResult<Quote> {
        if report_data.len() > 64 {
            return Err(EnclaveRaError::ReportDataLongerThan64Bytes);
        }

        // Obtain QE's target info to build a report for local attestation.
        // Then, send the report back to client.
        let mut _report_data = [0u8; 64];
        (&mut _report_data[..(report_data.len())]).copy_from_slice(report_data);
        let mut target_info = [0u8; Targetinfo::UNPADDED_SIZE];
        client_stream.read_exact(&mut target_info).unwrap();
        let target_info = Targetinfo::try_copy_from(&target_info).unwrap();
        let report = Report::for_target(&target_info, &_report_data);


        //add some custom data to report, then get the quote
        client_stream.write_all(report.as_ref()).unwrap();

        // Obtain quote and QE report from client
        // let mut quote = [0u8; size_of::<Quote>()];
        client_stream.read_exact(&mut self.quote[..]).unwrap();
        let qe_report_len = 432usize;
        let mut qe_report = vec![0u8; qe_report_len];
        client_stream.read_exact(&mut qe_report[..]).unwrap();

        // Verify that the report is generated by QE
        local_attestation::verify_local_attest(&qe_report[..])
            .map_err(|e| EnclaveRaError::LocalAttestation(e))?;
        Ok(self.quote)
    }
}
pub mod context;
pub mod error;
pub mod local_attestation;
pub mod tls_enclave;
// pub mod attestation_response;

pub use crate::context::*;
pub use crate::error::*;
pub use crate::tls_enclave::*;
// pub use crate::attestation_response::*;

pub type EnclaveRaResult<T> = Result<T, EnclaveRaError>;
#[derive(Debug)]
pub enum EnclaveRaError {
    Crypto(sgx_crypto::error::CryptoError),
    IntegrityError,
    ReportDataLongerThan64Bytes,
    LocalAttestation(LocalAttestationError),
    EnclaveNotTrusted,
    PseNotTrusted,
}

impl std::convert::From<sgx_crypto::error::CryptoError> for EnclaveRaError {
    fn from(e: sgx_crypto::error::CryptoError) -> Self {
        Self::Crypto(e)
    }
}

#[derive(Debug)]
pub enum LocalAttestationError {
    Crypto(sgx_crypto::error::CryptoError),
    IncorrectReportLength,
    IntegrityError,
}

impl std::convert::From<sgx_crypto::error::CryptoError> for LocalAttestationError {
    fn from(e: sgx_crypto::error::CryptoError) -> Self {
        Self::Crypto(e)
    }
}

#[derive(Debug)]
pub enum AttestationError {
    MismatchedIASRootCertificate,
    InvalidIASCertificate,
    BadSignature,
}// Modified from https://gist.github.com/Vinc0682/10c074202c995e4f87b4edf278ec4cae
use crate::error::LocalAttestationError;
use sgx_crypto::cmac::Cmac;
use sgx_isa::{Keyname, Keyrequest, Report, Targetinfo};

/// Fetches the own target info and puts it into a byte-vector.
pub fn get_own_targetinfo() -> Vec<u8> {
    let ti = Targetinfo::from(Report::for_self());
    let result: &[u8] = ti.as_ref();
    result.to_vec().clone()
}

/// Tries to create a report for the given target and puts it into a byte-vector.
/// Returns None if the target is invalid, returns the report otherwise.
pub fn locally_attest(target: &Vec<u8>, data: &[u8; 64]) -> Option<Vec<u8>> {
    let ti = Targetinfo::try_copy_from(&target[..])?;
    let report = Report::for_target(&ti, data);
    let report: &[u8] = report.as_ref();
    Some(report.to_vec().clone())
}

/// Verifies a report created by locally_attest (or any other report generated by an enclave).
/// Returns true if the report is correctly formed and has been generated on the same machine/CPU
/// as the current enclave.
pub fn verify_local_attest(report: &[u8]) -> Result<(), LocalAttestationError> {
    if report.len() != Report::UNPADDED_SIZE {
        return Err(LocalAttestationError::IncorrectReportLength);
    }
    // Can unwrap since the length is verified
    let report = Report::try_copy_from(report).unwrap();
    verify_report(&report)
}

/// Verifies the given report locally, a.k.a. returns true if the Report was created in an enclave
/// on the same CPU.
pub fn verify_report(report: &Report) -> Result<(), LocalAttestationError> {
    // Derive the report key.
    let request = Keyrequest {
        keyname: Keyname::Report as _,
        keyid: report.keyid.clone(),
        ..Default::default()
    };
    // Maybe result false instead of panicking, but the specs
    // ( https://software.intel.com/en-us/articles/intel-sdm Volume 3C, Chapter 40-4 )
    // state that EGETKEY should have a problem with this parameters, so if it doesn't work
    // there might be a deeper issue making a panic appropriate.
    let key = request.egetkey().expect("Can't derive report key");

    // Extract the data that is signed.
    let report_data: &[u8] = report.as_ref();
    let mut mac_data = &report_data[0..Report::UNPADDED_SIZE - 48];

    // Compute and verify the mac on the data.
    let mut mac = Cmac::new(&key)?;
    mac.verify(&mut mac_data, &report.mac)
        .map_err(|_| LocalAttestationError::IntegrityError)
}
use byteorder::{NetworkEndian, ReadBytesExt, WriteBytesExt};
use hyper::Response;
use ra_common::tcp::tcp_connect;
use ra_sp::{AttestationResult, HttpRespWrap, SpConfigs, SpRaContext};
use sgx_crypto::random::Rng;
use sgx_crypto::tls_psk::client;
use std::collections::HashMap;
use std::io::{BufReader, Read, Write};
use std::mem;
use std::net::{TcpListener};
use std::sync::Arc;
use std::time::Duration;

const SCHEDULE_ID: u8 = 255;
const STOP_LABEL: u8 = 250;
fn parse_config_file(path: &str) -> SpConfigs {
    serde_json::from_reader(std::fs::File::open(path).unwrap()).unwrap()
}

fn main() {
    let configs = parse_config_file("examples/data/settings.json");
    let listener_address = configs.listener_address.clone();
    let mut http_report = HashMap::new();
    let listener = TcpListener::bind(listener_address).unwrap();
    //listener.set_nonblocking(true).expect("Cannot set non-blocking");
    eprintln!("SP: listening at {:?}.", configs.listener_address.clone());
    for stream in listener.incoming() {
        eprintln!("SP: new socket incoming.");
        match stream {
            Err(e) => {
                eprintln!("failed: {}", e);
                continue;
            }
            Ok(mut stream) => {
                let enclave_id = stream.read_u8().unwrap();
                let client_ip = stream.peer_addr().unwrap().ip();
                let spconfig = match configs.generate_spconfig(enclave_id, &client_ip) {
                    Err(e) => {
                        eprintln!("client err, ip:{}", stream.peer_addr().unwrap());
                        eprintln!("the client socket is not configed in settings.json: {}", e);
                        continue;
                    }
                    Ok(config) => config,
                };
                let enclave_port = spconfig.enclave_port.clone();
                let mut context = SpRaContext::init(spconfig).unwrap();
                let result = match context.do_attestation(&mut stream) {
                    Ok(result) => {
                        let http_resp =
                            mem::replace(&mut context.get_ias_client().http_resp, None).unwrap();
                        http_report.insert(context.get_spconfig().enclave_id, http_resp);
                        println!("enclave_id: {}", context.get_spconfig().enclave_id);
                        result
                    }
                    Err(e) => {
                        println!("Do remote attestation failed, the reason is: {}", e);
                        continue;
                    }
                };
                if context.get_spconfig().enclave_id == SCHEDULE_ID {
                    send_http_report_to_schedule(&mut http_report, enclave_port);
                    continue;
                } else {
                    // establish TLS-PSK with enclave; SP is the client
                    do_tls_psk(result, enclave_port, keep_message);
                }
            }
        }
    }
}
// establish TLS-PSK with enclave; SP is the client
pub fn do_tls_psk(
    result: AttestationResult,
    enclave_port: String,
    keep_message: fn(BufReader<mbedtls::ssl::Context>),
) {
    let timeout = Duration::from_secs(5);
    let enclave_stream =
        tcp_connect(&enclave_port, timeout).expect("SP: Enclave connection failed");
    let rng = Rng::new();
    let config = client::config(rng, &result.master_key).unwrap();
    let rc_config = Arc::new(config);
    let mut ctx = client::context(rc_config);

    // begin secure communication
    ctx.establish(enclave_stream, None).unwrap();
    let session = BufReader::new(ctx);
    keep_message(session);
}
//enable enclave can communite with sp for more message
pub fn keep_message(session: BufReader<mbedtls::ssl::Context>) {
    let mut sess = session;
    let len = sess.read_u32::<NetworkEndian>().unwrap() as usize;
    let mut msg = vec![0u8; len];
    sess.read_exact(&mut msg[..]).unwrap();
    let msg = std::str::from_utf8(msg.as_slice()).unwrap();
    let msg_ref = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque non placerat risus, et lobortis quam. Mauris velit lorem, elementum id neque a, aliquet tempus turpis. Nam eu congue urna, in semper quam. Ut tristique gravida nunc nec feugiat. Proin tincidunt massa a arcu volutpat, sagittis dignissim velit convallis. Cras ac finibus lorem, nec congue felis. Pellentesque fermentum vitae ipsum sed gravida. Nulla consectetur sit amet erat a pellentesque. Donec non velit sem. Sed eu metus felis. Nullam efficitur consequat ante, ut commodo nisi pharetra consequat. Ut accumsan eget ligula laoreet dictum. Maecenas tristique porta convallis. Suspendisse tempor sodales velit, ac luctus urna varius eu. Ut ultrices urna vestibulum vestibulum euismod. Vivamus eu sapien urna.";
    assert_eq!(msg, msg_ref);
    eprintln!("SP: message from Enclave = \"{}\"", msg);
    eprintln!("SP: done!");
}
//send all of the report getting from IAS to schedule for check
pub fn send_http_report_to_schedule(
    http_report: &mut HashMap<u8, Response<Vec<u8>>>,
    enclave_port: String,
) {
    let timeout = Duration::from_secs(50);
    println!("{}", enclave_port);
    let mut enclave_stream =
        tcp_connect(&enclave_port, timeout).expect("SP: Enclave connection failed");
    for (k, v) in http_report {
        enclave_stream.write_u8(*k).unwrap();
        let wrapped = HttpRespWrap {
            map: v.headers().clone(),
            statu: v.status(),
        };
        let header = serde_json::to_vec(&wrapped).unwrap();
        let len = header.len() as u32;
        enclave_stream.write_u32::<NetworkEndian>(len).unwrap();
        enclave_stream.write_all(&header).unwrap();
        let body = v.body_mut();
        let len = body.len() as u32;
        enclave_stream.write_u32::<NetworkEndian>(len).unwrap();
        enclave_stream.write_all(&body).unwrap();
    }
    enclave_stream.write_u8(STOP_LABEL).unwrap();
}
extern crate clap;
use ra_sp::{context::verify_quote, SpConfigs};
// use byteorder::{NetworkEndian, WriteBytesExt}; 
use ra_common::tcp::tcp_connect;
use std::time::Duration;
use std::io::Write;
use clap::App;

fn parse_config_file(path: &str) -> SpConfigs {
    serde_json::from_reader(std::fs::File::open(path).unwrap()).unwrap()
}

fn main() {
    let matches = App::new("tvm-user")
        .version("1.0")
        .author("simplelin. ")
        .about("Do remote attestation")
        .args_from_usage(
            "-e   --enclave=[String] 'Sets IP and Port for sgx task enclave,such as: \"127.0.0.1:7777\"'
            -n   --number=[u8]     'Serial number for the enclave that will send quote to client,\"0-255\".such as:0' ")
        .get_matches();
    let enclave  = matches.value_of("enclave").unwrap_or("127.0.0.1:7777");
    let number  = matches.value_of("number").unwrap_or("0");//.as_bytes();
    let number  = number.parse::<u8>().expect("the input value is invalid,that should be a id and type is \"u8\"");
    let timeout = Duration::from_secs(5);
    let mut enclave_stream =
        tcp_connect(enclave, timeout).expect("Client: Enclave connection failed");
    eprintln!("Client: connected to enclave {:?}.", enclave);
    
    eprintln!("Starting verify_quote .");
    let configs = parse_config_file("examples/data/settings.json");
    verify_quote(configs, &mut enclave_stream).unwrap();
    let rand_sig = [2u8; 4];
    enclave_stream.write_all(&rand_sig).unwrap();

}use crate::error::AttestationError;
use hyper::header::{HeaderMap, HeaderValue};
use regex::Regex;
use serde::Deserialize;
use serde_json::Value;
use sgx_crypto::certificate::X509Cert;

#[derive(Deserialize, Debug)]
pub struct AttestationResponse {
    // header
    pub advisory_url: Option<String>,
    pub advisory_ids: Option<String>,
    pub request_id: String,
    // body
    pub id: String,
    pub timestamp: String,
    pub version: u16,
    pub isv_enclave_quote_status: String,
    pub isv_enclave_quote_body: String,
    pub revocation_reason: Option<String>,
    pub pse_manifest_status: Option<String>,
    pub pse_manifest_hash: Option<String>,
    pub platform_info_blob: Option<String>,
    pub nonce: Option<String>,
    pub epid_pseudonym: Option<String>,
}

impl AttestationResponse {
    pub fn from_response(
        root_ca_cert: &X509Cert,
        headers: &HeaderMap,
        body: Vec<u8>,
    ) -> Result<Self, AttestationError> {
        Self::verify_response(root_ca_cert, &headers, &body[..])?;

        let body: Value = {
            let body = String::from_utf8(body).unwrap();
            serde_json::from_str(&body).unwrap()
        };
        if cfg!(feature = "verbose") {
            eprintln!("==============headers Result==============");
            eprintln!("{:#?}", headers);
            eprintln!("==============================================");
            eprintln!("==============body Result==============");
            eprintln!("{:#?}", body);
            eprintln!("==============================================");
        }
        let h = |x: &HeaderValue| x.to_str().unwrap().to_owned();
        let b = |x: &str| x.to_owned();
        Ok(Self {
            // header
            advisory_ids: headers.get("advisory-ids").map(h),
            advisory_url: headers.get("advisory-url").map(h),
            request_id: headers.get("request-id").map(h).unwrap(),
            // body
            id: body["id"].as_str().unwrap().to_owned(),
            timestamp: body["timestamp"].as_str().unwrap().to_owned(),
            version: body["version"].as_u64().unwrap() as u16,
            isv_enclave_quote_status: body["isvEnclaveQuoteStatus"].as_str().unwrap().to_owned(),
            isv_enclave_quote_body: body["isvEnclaveQuoteBody"].as_str().unwrap().to_owned(),
            revocation_reason: body["revocationReason"].as_str().map(b),
            pse_manifest_status: body["pseManifestStatus"].as_str().map(b),
            pse_manifest_hash: body["pseManifestHash"].as_str().map(b),
            platform_info_blob: body["platformInfoBlob"].as_str().map(b),
            nonce: body["nonce"].as_str().map(b),
            epid_pseudonym: body["epidPseudonym"].as_str().map(b),
        })
    }

    fn verify_response(
        root_ca_cert: &X509Cert,
        headers: &HeaderMap,
        body: &[u8],
    ) -> Result<(), AttestationError> {
        // Split certificates
        let re = Regex::new(
            "(-----BEGIN .*-----\\n)\
                            ((([A-Za-z0-9+/]{4})*\
                              ([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)*\\n)+)\
                            (-----END .*-----)",
        )
        .unwrap();
        let (mut certificate, mut ca_certificate) = {
            let c = headers
                .get("x-iasreport-signing-certificate")
                .unwrap()
                .to_str()
                .unwrap();
            let c = percent_encoding::percent_decode_str(c)
                .decode_utf8()
                .unwrap();
            let c = re
                .find_iter(&c)
                .map(|m| m.as_str().to_owned())
                .collect::<Vec<String>>();
            let mut c_iter = c.into_iter();
            let mut certificate = c_iter.next().unwrap();
            certificate.push('\0');
            let certificate = X509Cert::new_from_pem(certificate.as_bytes()).unwrap();
            let mut ca_certificate = c_iter.next().unwrap();
            ca_certificate.push('\0');
            let ca_certificate = X509Cert::new_from_pem(ca_certificate.as_bytes()).unwrap();
            (certificate, ca_certificate)
        };

        // Check if the root certificate is the same as the SP-provided certificate
        if root_ca_cert != &ca_certificate {
            return Err(AttestationError::MismatchedIASRootCertificate);
        }

        // Check if the certificate is signed by root CA
        certificate
            .verify_this_certificate(&mut ca_certificate)
            .map_err(|_| AttestationError::InvalidIASCertificate)?;

        // Check if the signature is correct
        let signature = base64::decode(
            headers
                .get("x-iasreport-signature")
                .unwrap()
                .to_str()
                .unwrap(),
        )
        .unwrap();
        certificate
            .verify_signature(body, &signature[..])
            .map_err(|_| AttestationError::BadSignature)?;
        Ok(())
    }
}
use crate::config::{SpConfig, SpConfigs};
use crate::error::SpRaError;
use crate::ias::IasClient;
use crate::{AttestationResult, SpRaResult};
use byteorder::{LittleEndian, ReadBytesExt};
use mbedtls::rng::Random;
use ra_common::derive_secret_keys;
use ra_common::msg::{Quote, RaMsg0, RaMsg1, RaMsg2, RaMsg3, RaMsg4, Spid};
use sgx_crypto::certificate::X509Cert;
use sgx_crypto::cmac::{Cmac, MacTag};
use sgx_crypto::digest::{sha256, Sha256Digest};
use sgx_crypto::key_exchange::{DHKEPublicKey, OneWayAuthenticatedDHKE};
use sgx_crypto::signature::{SigningKey, VerificationKey};
use byteorder::{NetworkEndian, WriteBytesExt};
use sgx_crypto::random::Rng;
use sgxs::sigstruct;
use std::convert::TryInto;
use std::fs::File;
use std::io::{Read, Write};
use std::path::Path;
use std::time::SystemTime;
use std::mem::size_of;
// use aesm_client::unix::AesmClientExt;

pub struct SpRaContext {
    config: SpConfig,
    sigstruct: sigstruct::Sigstruct,
    ias_client: IasClient,
    sp_private_key: SigningKey,
    rng: Rng,
    key_exchange: Option<OneWayAuthenticatedDHKE>,
    g_a: Option<DHKEPublicKey>,
    verification_digest: Option<Sha256Digest>,
    smk: Option<Cmac>,
    sk_mk: Option<(MacTag, MacTag)>,
}

impl SpRaContext {
    pub fn init(mut config: SpConfig) -> SpRaResult<Self> {
        assert!(config.linkable, "Only Linkable Quote supported");
        assert!(!config.random_nonce, "Random nonces not supported");
        assert!(
            !config.use_platform_service,
            "Platform service not supported"
        );
        if cfg!(feature = "verbose") {
            eprintln!("==================SP Config==================");
            eprintln!("{:#?}", config);
            eprintln!("=============================================");
        }

        // Preparing for binary search
        config.quote_trust_options.sort();
        config.pse_trust_options.as_mut().map(|v| v.sort());

        let cert = X509Cert::new_from_pem_file(Path::new(&config.ias_root_cert_pem_path))?;

        let mut rng = Rng::new();
        let key_exchange = OneWayAuthenticatedDHKE::generate_keypair(&mut rng)?;
        let sp_private_key =
            SigningKey::new_from_file(Path::new(&config.sp_private_key_pem_path), None)?;
        let mut sigstruct = File::open(Path::new(&config.sigstruct_path))?;
        let sigstruct = sigstruct::read(&mut sigstruct)?;

        Ok(Self {
            config,
            sigstruct,
            ias_client: IasClient::new(cert),
            sp_private_key,
            rng,
            key_exchange: Some(key_exchange),
            g_a: None,
            verification_digest: None,
            smk: None,
            sk_mk: None,
        })
    }
    //get a shared reference of SpConfig
    pub fn get_spconfig(&self) -> &SpConfig {
        &self.config
    }
    //get a shared reference of IasClient
    pub fn get_ias_client(&mut self) -> &mut IasClient {
        &mut self.ias_client
    }
    #[tokio::main]
    pub async fn do_attestation(
        &mut self,
        mut client_stream: &mut (impl Read + Write),
    ) -> SpRaResult<AttestationResult> {
        // Not using MSG0 for now.
        let _msg0: RaMsg0 = bincode::deserialize_from(&mut client_stream)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG0 received ");
        }
        let sy_time = SystemTime::now();
        let msg1: RaMsg1 = bincode::deserialize_from(&mut client_stream)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG1 received");
        }
        println!(
            "{:?}",
            SystemTime::now()
                .duration_since(sy_time)
                .unwrap()
                .as_micros()
        );
        let sy_time = SystemTime::now();
        let msg2 = self.process_msg_1(msg1).await?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG1 processed");
        }
        bincode::serialize_into(&mut client_stream, &msg2)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG2 sent");
        }
        println!(
            "{:?}",
            SystemTime::now()
                .duration_since(sy_time)
                .unwrap()
                .as_micros()
        );
        let sy_time = SystemTime::now();
        let msg3: RaMsg3 = bincode::deserialize_from(&mut client_stream)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG3 received");
        }
        println!(
            "{:?}",
            SystemTime::now()
                .duration_since(sy_time)
                .unwrap()
                .as_micros()
        );
        let sy_time = SystemTime::now();
        let (msg4, epid_pseudonym) = self.process_msg_3(msg3).await?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG4 generated");
        }
        println!(
            "{:?}",
            SystemTime::now()
                .duration_since(sy_time)
                .unwrap()
                .as_micros()
        );
        let sy_time = SystemTime::now();
        bincode::serialize_into(&mut client_stream, &msg4)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG4 sent");
        }

        if !msg4.is_enclave_trusted {
            return Err(SpRaError::EnclaveNotTrusted);
        }
        match msg4.is_pse_manifest_trusted {
            Some(t) => {
                if !t {
                    return Err(SpRaError::EnclaveNotTrusted);
                }
            }
            None => {}
        }

        let (signing_key, master_key) = self.sk_mk.take().unwrap();
        println!(
            "decode {:?}",
            SystemTime::now()
                .duration_since(sy_time)
                .unwrap()
                .as_micros()
        );
        Ok(AttestationResult {
            epid_pseudonym,
            signing_key,
            master_key,
        })
    }

    pub async fn process_msg_1(&mut self, msg1: RaMsg1) -> SpRaResult<RaMsg2> {
        // Get sigRL
        let sig_rl = self
            .ias_client
            .get_sig_rl(&msg1.gid, &self.config.primary_subscription_key);

        let key_exchange = self.key_exchange.take().unwrap();
        let g_b = key_exchange.get_public_key()?;

        // Sign and derive KDK and other secret keys
        let (kdk, sign_gb_ga) =
            key_exchange.sign_and_derive(&msg1.g_a, &mut self.sp_private_key, &mut self.rng)?;
        let mut kdk_cmac = Cmac::new(&kdk)?;
        let (smk, sk, mk, vk) = derive_secret_keys(&mut kdk_cmac)?;
        let smk = Cmac::new(&smk)?;

        // Obtain SHA-256(g_a || g_b || vk)
        let mut verification_msg = Vec::new();
        verification_msg.write_all(&msg1.g_a).unwrap();
        verification_msg.write_all(&g_b[..]).unwrap();
        verification_msg.write_all(&vk).unwrap();
        let verification_digest = sha256(&verification_msg[..])?;

        // Set context
        self.smk = Some(smk);
        self.sk_mk = Some((sk, mk));
        self.verification_digest = Some(verification_digest);
        self.g_a = Some(msg1.g_a.clone());

        let spid: Spid = hex::decode(&self.config.spid)
            .unwrap()
            .as_slice()
            .try_into()
            .unwrap();
        let quote_type = self.config.linkable as u16;

        Ok(RaMsg2::new(
            self.smk.as_mut().unwrap(),
            g_b,
            spid,
            quote_type,
            sign_gb_ga,
            sig_rl.await?,
        )?)
    }

    pub async fn process_msg_3(&mut self, msg3: RaMsg3) -> SpRaResult<(RaMsg4, Option<String>)> {
        // Integrity check
        if &msg3.g_a[..] != &self.g_a.as_ref().unwrap()[..] {
            return Err(SpRaError::IntegrityError);
        }
        if !msg3.verify_mac(self.smk.as_mut().unwrap()).is_ok() {
            return Err(SpRaError::IntegrityError);
        }
        let quote_digest: Sha256Digest = (&msg3.quote.as_ref()[368..400]).try_into().unwrap();
        //only try to compare 31bytes sha256 result,because the length is only to 64bytes and signer publick key need 33 bytes
        if &self.verification_digest.as_ref().unwrap()[..31] != &quote_digest[..31] {
            return Err(SpRaError::IntegrityError);
        }

        // Verify attestation evidence
        // TODO: use the secondary key as well
        let sy_time = SystemTime::now();
        let attestation_result = self
            .ias_client
            .verify_attestation_evidence(&msg3.quote, &self.config.primary_subscription_key)
            .await?;
        println!(
            "{:?}",
            SystemTime::now()
                .duration_since(sy_time)
                .unwrap()
                .as_micros()
        );

        if cfg!(feature = "verbose") {
            eprintln!("==============Attestation Result==============");
            eprintln!("{:#?}", attestation_result);
            eprintln!("==============================================");
        }

        // Verify enclave identity
        let mrenclave = &msg3.quote[112..144];
        let mrsigner = &msg3.quote[176..208];
        let isvprodid = (&msg3.quote[304..306]).read_u16::<LittleEndian>().unwrap();
        let isvsvn = (&msg3.quote[306..308]).read_u16::<LittleEndian>().unwrap();
        if mrenclave != self.sigstruct.enclavehash.as_ref()
            || mrsigner != sha256(self.sigstruct.modulus.as_ref())?.as_ref()
            || isvprodid != self.sigstruct.isvprodid
            || isvsvn != self.sigstruct.isvsvn
        {
            return Err(SpRaError::SigstructMismatched);
        }

        // Make sure the enclave is not in debug mode in production
        let attribute_flags = &self.sigstruct.attributes.flags;
        if cfg!(not(debug_assertions)) {
            if (&sgx_isa::AttributesFlags::DEBUG).intersects(*attribute_flags) {
                return Err(SpRaError::EnclaveInDebugMode);
            }
        }

        // Decide whether to trust enclave
        let quote_status = attestation_result.isv_enclave_quote_status.clone();
        let pse_manifest_status = attestation_result.pse_manifest_status.clone();
        let is_enclave_trusted = (quote_status == "OK")
            || self
                .config
                .quote_trust_options
                .binary_search(&quote_status)
                .is_ok();
        let is_pse_manifest_trusted = pse_manifest_status.map(|status| {
            (status == "OK")
                || self
                    .config
                    .pse_trust_options
                    .as_ref()
                    .unwrap()
                    .binary_search(&status)
                    .is_ok()
        });

        Ok((
            RaMsg4 {
                is_enclave_trusted,
                is_pse_manifest_trusted,
                pib: attestation_result.platform_info_blob,
            },
            attestation_result.epid_pseudonym,
        ))
    }
}
#[tokio::main]
pub async fn verify_quote(
    mut config: SpConfigs,
    enclave_stream: &mut (impl Read + Write),
) -> SpRaResult<()> {
    config.quote_trust_options.sort();
    config.pse_trust_options.as_mut().map(|v| v.sort());
    let mut rng = Rng::new();
    let mut rand_data = vec![0u8; 64];
    rng.inner.random( &mut rand_data ).expect("error for rand data!");
    enclave_stream.write_all(&rand_data).unwrap();
    let sig_len = enclave_stream.read_u32::<NetworkEndian>().unwrap() as usize;
    // Obtain quote and QE report from client
    let mut quote = [0u8; size_of::<Quote>()];
    enclave_stream.read_exact(&mut quote[..]).unwrap(); 

    let mut rand_sig = vec![0u8; sig_len];
    enclave_stream.read_exact(&mut rand_sig[..]).unwrap();
    let ec_public_key = &mut quote[399..432];
    let mut verify_key = VerificationKey::new_from_binary(&ec_public_key)
    // let mut verify_key = VerificationKey::new(&ec_public_key[..33])
        .expect("get new verify public key failed!");
    verify_key
        .verify(&rand_data, &rand_sig)
        .expect("verify failed!");
    enclave_stream.write_all(&[1u8;4]).unwrap();
    //send quote to intel
    // let configs = parse_config_file("examples/data/settings.json");
    let cert = X509Cert::new_from_pem_file(Path::new(&config.ias_root_cert_pem_path))?;
    let attestation_result = IasClient::new(cert)
        .verify_attestation_evidence(&quote, &config.primary_subscription_key)
        .await?;
    if cfg!(feature = "verbose") {
        eprintln!("==============Attestation Result==============");
        eprintln!("{:#?}", attestation_result);
        eprintln!("==============================================");
    }
    // Decide whether to trust enclave
    let quote_status = attestation_result.isv_enclave_quote_status.clone();
    let pse_manifest_status = attestation_result.pse_manifest_status.clone();
    let is_enclave_trusted = (quote_status == "OK")
        || config
            .quote_trust_options
            .binary_search(&quote_status)
            .is_ok();
    let is_pse_manifest_trusted = pse_manifest_status.map(|status| {
        (status == "OK")
            || config
                .pse_trust_options
                .as_ref()
                .unwrap()
                .binary_search(&status)
                .is_ok()
    });
    if !is_enclave_trusted {
        return Err(SpRaError::EnclaveNotTrusted);
    }
    match is_pse_manifest_trusted {
        Some(t) => {
            if !t {
                return Err(SpRaError::PseNotTrusted);
            }
        }
        None => {}
    }
    Ok(())
}
use crate::SpRaResult;
use http::{HeaderMap, StatusCode};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;

#[derive(Deserialize, Debug, Clone)]
pub struct AttestationInfo {
    pub id: u8,
    pub client_ip: String,
    pub enclave_port: String,
    pub sp_private_key_pem_path: String,
    pub sigstruct_path: String,
}

#[derive(Deserialize, Debug, Clone)]
pub struct SpConfig {
    pub enclave_id: u8,
    pub linkable: bool,
    pub random_nonce: bool,
    pub use_platform_service: bool,
    pub spid: String,
    pub primary_subscription_key: String,
    pub secondary_subscription_key: String,
    pub quote_trust_options: Vec<String>,
    pub pse_trust_options: Option<Vec<String>>,
    pub ias_root_cert_pem_path: String,
    pub sp_private_key_pem_path: String,
    pub sigstruct_path: String,
    pub enclave_port: String,
}

#[derive(Deserialize, Debug, Clone)]
pub struct SpConfigs {
    pub linkable: bool,
    pub random_nonce: bool,
    pub use_platform_service: bool,
    pub spid: String,
    pub primary_subscription_key: String,
    pub secondary_subscription_key: String,
    pub quote_trust_options: Vec<String>,
    pub pse_trust_options: Option<Vec<String>>,
    pub ias_root_cert_pem_path: String,
    pub listener_address: String,
    pub slaves: Vec<AttestationInfo>,
}

impl SpConfigs {
    pub fn generate_spconfig(&self, id: u8, peer_ip: &IpAddr) -> SpRaResult<SpConfig> {
        let mut sp_private_key_pem_path = "".to_string();
        let mut enclave_port = "".to_string();
        let mut exit: bool = false;
        let mut sigstruct_path = "".to_string();
        println!("slave id: {:?} ", id);
        //let id = idstr.parse::<u8>().expect("the input value is invalid,that should be a id and type is \"u8\"");
        for slave in self.slaves.iter() {
            //slaves.push(slave.clone());
            //if slave.client_port.parse::<SocketAddr>()  == Ok(*peer_socket){
            if slave.client_ip.parse::<IpAddr>() == Ok(*peer_ip)
                && "127.0.0.1".parse::<IpAddr>() != Ok(*peer_ip)
            {
                sp_private_key_pem_path = slave.sp_private_key_pem_path.clone();
                sigstruct_path = slave.sigstruct_path.clone();
                enclave_port = slave.enclave_port.clone();
                exit = true;
                break;
            } else if "127.0.0.1".parse::<IpAddr>() == Ok(*peer_ip) && id == slave.id {
                sp_private_key_pem_path = slave.sp_private_key_pem_path.clone();
                sigstruct_path = slave.sigstruct_path.clone();
                enclave_port = slave.enclave_port.clone();
                exit = true;
                break;
            }
        }
        match true == exit {
            true => Ok(SpConfig {
                sp_private_key_pem_path,
                sigstruct_path,
                enclave_port,
                enclave_id: id,
                linkable: self.linkable.clone(),
                random_nonce: self.random_nonce.clone(),
                use_platform_service: self.use_platform_service.clone(),
                spid: self.spid.clone(),
                primary_subscription_key: self.primary_subscription_key.clone(),
                secondary_subscription_key: self.secondary_subscription_key.clone(),
                quote_trust_options: self.quote_trust_options.clone(),
                pse_trust_options: self.pse_trust_options.clone(),
                ias_root_cert_pem_path: self.ias_root_cert_pem_path.clone(),
            }),
            false => Err(super::error::SpRaError::ClientConfigNotFound),
        }
    }

    // pub fn generate_spconfig(&self,peer_ip:& IpAddr) -> SpRaResult<SpConfig> {
    //     let mut sp_private_key_pem_path = "".to_string();
    //     let mut exit: bool = false;
    //     let mut sigstruct_path = "".to_string();
    //     for slave in self.slaves.iter() {
    //         //print!("{:#?} ", slave);
    //         //slaves.push(slave.clone());
    //         //if slave.client_port.parse::<SocketAddr>()  == Ok(*peer_socket){
    //         if slave.client_ip.parse::<IpAddr>()  ==  Ok(*peer_ip){
    //             sp_private_key_pem_path = slave.sp_private_key_pem_path.clone();
    //             sigstruct_path = slave.sigstruct_path.clone();
    //             exit = true;
    //             break;
    //         }
    //     }
}

//send http response with socket
#[derive(Serialize, Deserialize)]
pub struct HttpRespWrap {
    #[serde(with = "http_serde::header_map")]
    pub map: HeaderMap,
    #[serde(with = "http_serde::status_code")]
    pub statu: StatusCode,
}
mod attestation_response;
mod config;
pub mod context;
mod error;
mod ias;

pub use crate::config::*;
pub use crate::context::*;
pub use crate::error::*;

pub type SpRaResult<T> = Result<T, crate::error::SpRaError>;

use sgx_crypto::cmac::MacTag;

pub struct AttestationResult {
    pub epid_pseudonym: Option<String>,
    pub signing_key: MacTag,
    pub master_key: MacTag,
}
#[derive(Debug)]
pub enum SpRaError {
    Crypto(sgx_crypto::error::CryptoError),
    IO(std::io::Error),
    IAS(IasError),
    Serialization(std::boxed::Box<bincode::ErrorKind>),
    IntegrityError,
    SigstructMismatched,
    EnclaveInDebugMode,
    EnclaveNotTrusted,
    ClientConfigNotFound,
    PseNotTrusted
}

impl std::convert::From<std::io::Error> for SpRaError {
    fn from(e: std::io::Error) -> Self {
        Self::IO(e)
    }
}

impl std::convert::From<sgx_crypto::error::CryptoError> for SpRaError {
    fn from(e: sgx_crypto::error::CryptoError) -> Self {
        Self::Crypto(e)
    }
}

impl std::convert::From<IasError> for SpRaError {
    fn from(e: IasError) -> Self {
        Self::IAS(e)
    }
}

impl std::convert::From<std::boxed::Box<bincode::ErrorKind>> for SpRaError {
    fn from(e: std::boxed::Box<bincode::ErrorKind>) -> Self {
        Self::Serialization(e)
    }
}

impl std::fmt::Display for SpRaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(f, "{:?}", self)
    }
}

impl std::error::Error for SpRaError {}

#[derive(Debug)]
pub enum AttestationError {
    Connection(http::StatusCode),
    MismatchedIASRootCertificate,
    InvalidIASCertificate,
    BadSignature,
}

#[derive(Debug)]
pub enum IasError {
    IO(std::io::Error),
    Connection(hyper::error::Error),
    SigRLError(http::StatusCode),
    Attestation(AttestationError),
}

impl std::convert::From<std::io::Error> for IasError {
    fn from(e: std::io::Error) -> Self {
        Self::IO(e)
    }
}

impl std::convert::From<hyper::error::Error> for IasError {
    fn from(e: hyper::error::Error) -> Self {
        Self::Connection(e)
    }
}
use crate::attestation_response::AttestationResponse;
use crate::error::{AttestationError, IasError};
use hyper::body::HttpBody;
use hyper::{client::HttpConnector, Body, Client, Request, Response};
use hyper_tls::HttpsConnector;
use ra_common::msg::{Gid, Quote};
use sgx_crypto::certificate::X509Cert;
use std::io::Write;

const BASE_URI: &str = "https://api.trustedservices.intel.com/sgx/dev";
const SIG_RL_PATH: &str = "/attestation/v3/sigrl/";
const REPORT_PATH: &str = "/attestation/v3/report";

pub struct IasClient {
    https_client: Client<HttpsConnector<HttpConnector>>,
    root_ca_cert: X509Cert,
    pub http_resp: Option<Response<Vec<u8>>>,
}

impl IasClient {
    pub fn new(root_ca_cert: X509Cert) -> Self {
        Self {
            https_client: Client::builder().build::<_, hyper::Body>(HttpsConnector::new()),
            root_ca_cert,
            http_resp: None,
        }
    }

    pub async fn get_sig_rl(
        &self,
        gid: &Gid,
        subscription_key: &str,
    ) -> Result<Option<Vec<u8>>, IasError> {
        let uri = format!(
            "{}{}{:02x}{:02x}{:02x}{:02x}",
            BASE_URI, SIG_RL_PATH, gid[0], gid[1], gid[2], gid[3]
        );
        let req = Request::get(uri)
            .header("Ocp-Apim-Subscription-Key", subscription_key)
            .body(Body::empty())
            .unwrap();
        let mut resp = self.https_client.request(req).await?;
        if resp.status().as_u16() != 200 {
            return Err(IasError::SigRLError(resp.status()));
        }
        if resp.headers().get("content-length").unwrap() == "0" {
            return Ok(None);
        }
        let mut sig_rl = Vec::new();
        while let Some(chunk) = resp.body_mut().data().await {
            sig_rl.write_all(&chunk.unwrap()).unwrap();
        }
        Ok(Some(sig_rl))
    }

    pub async fn verify_attestation_evidence(
        &mut self,
        quote: &Quote,
        subscription_key: &str,
    ) -> Result<AttestationResponse, IasError> {
        let uri = format!("{}{}", BASE_URI, REPORT_PATH);
        if cfg!(feature = "verbose") {
            eprintln!("==============msg3.quote Result==============");
            eprintln!("{:?}", base64::encode(&quote[..432]));
            eprintln!("==============================================");
        }
        let quote_base64 = base64::encode(&quote[..]);
        let body = format!("{{\"isvEnclaveQuote\":\"{}\"}}", quote_base64);
        let req = Request::post(uri)
            .header("Content-type", "application/json")
            .header("Ocp-Apim-Subscription-Key", subscription_key)
            .body(Body::from(body))
            .unwrap();
        let mut resp = self.https_client.request(req).await?;
        if resp.status().as_u16() != 200 {
            return Err(IasError::Attestation(AttestationError::Connection(
                resp.status(),
            )));
        }

        let mut body = Vec::new();
        while let Some(chunk) = resp.body_mut().data().await {
            body.write_all(&chunk.unwrap()).unwrap();
        }
        let body2 = body.clone();
        let attresp = AttestationResponse::from_response(&self.root_ca_cert, resp.headers(), body)
            .map_err(|e| IasError::Attestation(e));
        let (http_parts, _) = resp.into_parts();
        self.http_resp = Some(Response::from_parts(http_parts, body2));
        attresp
    }
}
/* Copyright (c) Fortanix, Inc.
 *
 * Licensed under the GNU General Public License, version 2 <LICENSE-GPL or
 * https://www.gnu.org/licenses/gpl-2.0.html> or the Apache License, Version
 * 2.0 <LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0>, at your
 * option. This file may not be copied, modified, or distributed except
 * according to those terms. */

#![allow(dead_code)]

pub const PEM_KEY: &'static [u8] = b"-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDFjAgmCJUmKAQ/
OAg0MBh3E2+l5asSHdBNmTm0gr3vmnmFcUqlIpUG3BGd85o0c9X5qnxBKJafTJLu
2xRqjx1TMlBdtVpP0CXy5qPYwvO8UWIGyrsniy8GfpDjXGkUFbm91Cw1c/lCD7R1
6lLHK+7Npq9oxpk3KfMHivQorFd31byo0VxZv/sFYViCbDtOYmMifQX/qkqsbvkx
SuPklzpxAxF824mtKMRimwGQbZ4tbLlAFNugO02eV0Hq8xHxfbmNrblSqIy68/Ud
jg4Y9feFi8NVfYg/rsFjuL+Fv/3dLBBhaMffyV9J0eULXgVw5ZXNaQgKb6sSBQqi
U3LftHDTAgMBAAECggEBAKzBKN8Z4lTb6drfRU1eQgbgGGMb1d6h8+fod25EZ5WB
oYPw7zY6Z9j32vAmeFQmeJk9XiwdMptce6ImNFR7k0mOVnmcfr4NaSJiUCbfVgb5
pKAL6l9KeHVVeZ9a0Qmfdi9rvL2CDhiXY1k68ej7onp1qjAWfSagqMeP3LU1Acjo
tYnt42QNa/x4spOCx9EoMuKrEiBNYoll7lW6iuIqTO9Oodkh7ZHVEYNe3y4RHIpj
QmMxVrjt9Pe26cesNajkM2OWMxZW8MEeyL7DqUenxNluRrMG2lP5ZtEBuDFRTWEL
xrh89UQcFN0MZPL+HmMunS+ztu0vOh2UQw8zORSw+AECgYEA/DNK/kTJeRC0N4xh
ErcwTUBx2vtYdD/lWo4dRBanw218mXnzu25l8CjOQm0OircELy/UG0eBGCGXaxhh
H274KQqgM7ibSJHTP2J17wfbS3PxIgF75uf7UNP0M2yX/t2bjgfCsaqNckHBIrxN
Ym/FWUN884zrgapaYtiPzjTUF3MCgYEAyIXyguElCI7iYIN0qreSHvt+2qKyKhVO
6NdPf19ZvhT7vk03P6YXt/VCg+eNDeh5EBwHUWG2JQYznIK2jRLFwoFLdIlIjapq
kG9s2NWQ99HpY0mnhTUFptTEpiuyFDbEyhXhWBja5zOn1ZuqW/V9bgCglGoxOckV
2vGv4YX0KSECgYEA0YUTcnZXItr7vYJESzYhTKyTaieR7tH+iuKx8ZUYvsTA1Qh5
smcfDQv5fzn28MrnEQSdJCSdXRzbHL/eQC0CwaXwPcfKSdnMNEZqT7CpQOALngK5
mrVzFk1f/TDkfXpB9xb/anaUmC2EdIUXjQXqYCQvNG8IYGrUOHZN0jQVV30CgYAV
HW209GpG5WzXBuChHWVol8j60sj5/3ZotEttuSelCWac2lqn/CBhQZU4eIh033bo
CFuI6UYZzfZfU7BPWJu0aJL+eXpHWJuSC/mlN4/lWJg/2UCnmTa4I411hgJheIbu
VLF+6lcao2jX6GVe+5GypKREHI6EbDU98dc4YzeboQKBgF/R6wCxhVt9kqSLYeGq
nGQmHqj2/0m7M9O/QS5a4L/3Oyu5YyNuPR6OBMdjivOdz4RwUi6+o9IEepzmN1cV
okcspBUohwqnqHwvdiQjB+RygIpmnXhchXxRok3wc745S1NBCbAL5V3sa6/61/1C
YLT4mPYORlR4AgzvpNOJiI3T
-----END PRIVATE KEY-----\0";

pub const PEM_CERT_SUBJECT: &'static str = "CN=mbedtls.example";

pub const PEM_CERT: &'static [u8] = b"-----BEGIN CERTIFICATE-----
MIIDCTCCAfGgAwIBAgIJALWh9vlifeRuMA0GCSqGSIb3DQEBCwUAMBoxGDAWBgNV
BAMTD21iZWR0bHMuZXhhbXBsZTAgFw0xODExMjMwNTQ5MTBaGA8yMTAwMDEwMTA1
NDkxMFowGjEYMBYGA1UEAxMPbWJlZHRscy5leGFtcGxlMIIBIjANBgkqhkiG9w0B
AQEFAAOCAQ8AMIIBCgKCAQEAxYwIJgiVJigEPzgINDAYdxNvpeWrEh3QTZk5tIK9
75p5hXFKpSKVBtwRnfOaNHPV+ap8QSiWn0yS7tsUao8dUzJQXbVaT9Al8uaj2MLz
vFFiBsq7J4svBn6Q41xpFBW5vdQsNXP5Qg+0depSxyvuzaavaMaZNynzB4r0KKxX
d9W8qNFcWb/7BWFYgmw7TmJjIn0F/6pKrG75MUrj5Jc6cQMRfNuJrSjEYpsBkG2e
LWy5QBTboDtNnldB6vMR8X25ja25UqiMuvP1HY4OGPX3hYvDVX2IP67BY7i/hb/9
3SwQYWjH38lfSdHlC14FcOWVzWkICm+rEgUKolNy37Rw0wIDAQABo1AwTjAdBgNV
HQ4EFgQUbkS8taBrhQDq7t19qFfRzi8q86kwHwYDVR0jBBgwFoAUbkS8taBrhQDq
7t19qFfRzi8q86kwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAD8JW
PJrqtwaTtmmpFv8Xn8K2Tq7BBKg7ANtEs9Ca2SstR9J0idH8YYq69+CHbihO0cVS
QYgkos9FA7NU8eV8twNBBrgSS30ZkIVRCZn72476lHQTWnctqHTqkNmypt5Bdosr
yC9+dy8UCm9UhjW100vu0Oi++/7LU3GOcEuFX65pz4cjFFRLCKmA0mvSiBV4UwWu
HYDzyrZMYYcIpPBj9S7gvoQDeHrpw7yfA5Of+60cZZjwPY9Ebud5ETWnkFqqcShE
PVTB987Vm6hLu5/oHF+JVW05ZdXID1BZvukBYXnwY9OHvU7fin8N/eT/SBTd2HxO
d1SSYr2U5pj0tNqaDQ==
-----END CERTIFICATE-----\0";

pub const ROOT_CA_CERT_SUBJECT: &'static str = "CN=RootCA";

pub const ROOT_CA_CERT: &'static [u8] = b"-----BEGIN CERTIFICATE-----
MIIE4jCCAsqgAwIBAgIBATANBgkqhkiG9w0BAQsFADARMQ8wDQYDVQQDEwZSb290
Q0EwHhcNMTkwOTA1MTg0NTMyWhcNMjEwMzA1MTg0NTI2WjARMQ8wDQYDVQQDEwZS
b290Q0EwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQD6AOBz7HbIi8w3
Wjjk16oglHRQcICTkvgfl6gbGuSjOoVHmOAn2EWT9AuXtcyNcVFyk90h0dsadqkJ
Enrk3BkTJQmtGW0u5UvcI+famYjZDvYQpGcgXBFmrH7/g/BN4v5VvdrXxUVy6Uyv
Ql60yG7JxlMY8K2OMV13bOpABXhnG/zNr1hCPLQWu52Mn3M1nudFBZff7tZz4dBo
YoMeXkIWQ3t2wypD3WunlQcuGxNOCcXONZRDzeUidh/Yv/4tTggZe8KAnEngKb86
KwKAhVjinGIN2C+ISpKsDurDxhExA2Na6+EbtLEgkI9AeoBz6tIjt/yv/inil+Du
fEDSmG+P97oY1GNcZMkftjjJd0u57YWz0Ck5bfHdgploh/1VHGdoC677MDWJOb31
O3mGdpTiBHP2Gh6Xwm8NuZc+tQSPVr/GaYg7slLBl/7GWU9QGjr9DGj/qYozD8tT
cazIHFh9zDP4XC+a+D+3lMA5EMfvVmDmr2QZJoiKBrxbNXXZ0QQcc+Wr9jFBBx/i
BRlpnxr+EDG+Q7nFnbG6x1DkvKhc1KDGBhq/HDb5bBVSr7Pjl2FMNh8HVX64mDbA
7clQJHa1rIjB+HxtZB5DNKQbRobyrWgkTpi5XHPhMw966zrhBWgOdAh+PSeq9FEf
Y0w328/EBWGqIg3rRMOvDAQpbojNdwIDAQABo0UwQzAOBgNVHQ8BAf8EBAMCAQYw
EgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUiS413SfVRGy7vVwkLIGdDA4y
yoswDQYJKoZIhvcNAQELBQADggIBAHcRzQhesOTpFG4KINJyzZf7a5lrc8kayTaL
lzSXW1pEl3/OFiMvOayjDq+yVAJB+5j3WZu8AOTFuZ4pBjz2I1hdIt5F2asqnVN3
8ymuC7t4gNAQGhWJldnsL58iTYGlxFciiT/8QSHJJjYRkKxyhF08Oj3Zbs13J4xc
ENLmwCZMFait+qm7aX3idnUa1XMGO26ioQOi0uEVqu9N4p62OQKd/76vmnaqmIAw
5s47DaaUi7DeiBguLZrNzfZcJTAHNM5VxCjsXW4PieN6mJhQSar40794n7HLHxtG
Xc5UdxT3nLclEAviDJFubA1N/szWtu4vdfehdAKCXkIjwoUEVEOpPYEeYr27JFlP
kaxezxswwxY2UD0MZq21FhO7SpVQdmmvfoJvjQwIsiyoa9UNzC6mTqsJPjln+2mK
p6WHzX+E6GeA7Ng6CyvJsHRsqbQdJ0OXHm4GIG2Z05r4AgBtvI6hkhSfAotBt3Xi
lo5BEO6SbUnPYo03zD4x/76c4j/uZLYxy2n+Qrlm2KTQIUu7KEsKdUnLAxjWYePH
VxcYz0/9Z5H4OzhW4J1Qd6OBW0dqETLlMJauPX5DV/slyYQQasPStEJGgiDiKG+B
Jpjv6PefPTqZawP6gPoGmhF4UyMRWZ+NgqLft1uXTHhrHdnrZFag1oPLjxWFs5hx
pElsC4v+
-----END CERTIFICATE-----\0";

pub const ROOT_CA_KEY: &'static [u8] = b"-----BEGIN PRIVATE KEY-----
MIIJQwIBADANBgkqhkiG9w0BAQEFAASCCS0wggkpAgEAAoICAQD6AOBz7HbIi8w3
Wjjk16oglHRQcICTkvgfl6gbGuSjOoVHmOAn2EWT9AuXtcyNcVFyk90h0dsadqkJ
Enrk3BkTJQmtGW0u5UvcI+famYjZDvYQpGcgXBFmrH7/g/BN4v5VvdrXxUVy6Uyv
Ql60yG7JxlMY8K2OMV13bOpABXhnG/zNr1hCPLQWu52Mn3M1nudFBZff7tZz4dBo
YoMeXkIWQ3t2wypD3WunlQcuGxNOCcXONZRDzeUidh/Yv/4tTggZe8KAnEngKb86
KwKAhVjinGIN2C+ISpKsDurDxhExA2Na6+EbtLEgkI9AeoBz6tIjt/yv/inil+Du
fEDSmG+P97oY1GNcZMkftjjJd0u57YWz0Ck5bfHdgploh/1VHGdoC677MDWJOb31
O3mGdpTiBHP2Gh6Xwm8NuZc+tQSPVr/GaYg7slLBl/7GWU9QGjr9DGj/qYozD8tT
cazIHFh9zDP4XC+a+D+3lMA5EMfvVmDmr2QZJoiKBrxbNXXZ0QQcc+Wr9jFBBx/i
BRlpnxr+EDG+Q7nFnbG6x1DkvKhc1KDGBhq/HDb5bBVSr7Pjl2FMNh8HVX64mDbA
7clQJHa1rIjB+HxtZB5DNKQbRobyrWgkTpi5XHPhMw966zrhBWgOdAh+PSeq9FEf
Y0w328/EBWGqIg3rRMOvDAQpbojNdwIDAQABAoICAAC3l+09NGoG3KMcAyXE6JwH
UP4aFIRX25ZbnQPW4+kD9fXqnln+6NQv0wiwYNHXDWDCw9OhAnvk8z8vamLVrsy7
QnfYptOHnNwYzkV2Q0o8HMCXeCRDn1koDYU2H65ZhFlCnioYSsa1nJ60Fgl2ubqi
cwKTTiwmQBpjmZhta5cAIY2Ffz9RZULbbuxEWNRCjG9KQNFHoh3a+/oQrkecBZyC
vQvuK2TecbydVNPxB/ElXgflZ3N6V7ntlNHOWzBOFP/dtwUfbabS99V24h70QvkD
cdSQVjKR5DHSKSI+ozX8yIAuRQsLTabGQ2Lv9wZeGhQ4JuVqWTxpKyAEAzuXbFp/
69n4uEABvYsWtQAaF06ZmpA1Ek40o8HynHOJQ+8RjdRflShah/EJLwrwar8ydlAq
6Q9UCH0xvd9USs2KL/XwSPMfKO+2JeDh98wZ4GKGbK/JfYTKxUyLuQNQRiCuuPI0
DP0dot6xNKtyiRvRsI1jrqzy1QvMiCrwAJ70lucc13XLas1nNCQCzZIcbq0L7/OI
qEfW5PUFyLrVfTEZM0EQs8eNw02G1R1XDBYD2hHlhBXgc5FECeM6EPtqxGylM/+m
8Dim5oZsEN/C5e/AgGiiQgoxadmxmZ9m+bfSqv+HAkgtOItBUX8frLqkYe9GL2Pr
qXI40pMCehI+QKB6h0UBAoIBAQD+B3isiDGk4qgkOLQOk4o0EQ2heaX04qyVjqCv
YseJhoKpnj2IimDG5xCA0VddeKJ+xHLVcEwvJgE75v+4khGQ8PSlA5WJXaznrm5I
UZX26DW8wyxjOxoWjFvnPv9NZYl3IWQp1aHimFIDTMtXMjkBbAI1MsX9un48mXqg
DWQt1xCckMH7KaQAjV5QibCsKYKn7vuOxSI5v1C757xK1BarmgRTtKMKO2iq6jOt
XEOcxqwMAhfzGGjotbJaa6QRe8ItUKsSp9txJQLI0r0nLWAt9MW68nkd+kpPGEZg
GAkKiouWdUKVhVPiFsbO0TmxQSgrABQYQkW19+OZwheZIzAhAoIBAQD78Wjo6oSi
jjBrwFgCCPKRvnA2KGPjUnn0q0LI/CQO7pymygTjLnieTo5Q3y1zpki/7dN7ZdC1
PLJk/3QbFblaYrDwA3ZitQoBFw76iswZgMnLJXDWhn8SW4NnyRPn9yP/BhjK4bIs
T1vBtwffNOx6/u1RWVECuPs3rHdyMmWlHpAX4Wn47XLjvNggbQcXtkmOpCBtD/xA
4Tty3Xbju2bmg69BkqbHk9dXvL0NHsarplif+ep5VviZbrJSOFgn4//Will0kWhL
FLiPoi86XXkUUhMQ3e9KTKZqnD7pVlKGBL91GsFKA8fb9dRXx7cx0ozNoGHteixL
9mOEIx3goiqXAoIBAQCqZuSiB7IVgx17PrY52OqqRo44NVwHy04t/MD5JW/oZtyb
X1SzlO+aPUGqx8KtJtEJ7EmDt5LDReEqB6iebQ1vhtL1JlRXEwl7WF0OEfxg5h+2
Ac5yuiCj4396vZ2Qk34E9dc04ON5Fuhc4lS8pynqNEO+39JEg6dOiz3gw1riDRRN
kiUtkB89Z5dOuy5SLn5AnGUOvlpZFmbXxXlfUKnsbqJcbB26LWPm0rfboLqSHgsm
+viJz2QARnHfiblDKRt2PlijaQog+czGXecYsq2D5mAFKcXpQA48xHHg3/6gnZNJ
WFtT5V4BmXm/HkZvCuAhCCpyo3ITwLdiWvptdVdBAoIBADGkKmiiNMoWvCGu/2g/
PRRMcq2pHa1fxdnYmMsjKzOp/kG60mW09V0z20TCBKGh5Pm0MZRBxnK/Z+MQll7z
09akVXqlJAFk7Hi0g2YITRjFUH1vfiE21PjYATdE3mA5SOVp3R60g7fJVyn/F1T6
h5HggwAhWh3wNseMeuiMV4zGTdv2tTuwBZAr2GXjNZ+NckbhveXfXXOnLWB/lHpg
pXDMB48jByuRzL9j19gq9ThDCXlT88g+w7LvpcEfivcpLHKoReH6+JK6nXbnnOii
HEZNuaX8JLb+DVg6Owcc1BvF+bdoMyeTQSDs+g7lsgnmE4o8jK8PAIVjIc6aYLuv
GDcCggEBAIe+FhtHJiCniXZNGuaBjqFHj7iowpdyIfdUsMrZiZThDipaL14x4cQj
b9NLQaiWX6m0Gn26a0PdzFNjE+drSYxSLbFrWIb2BKA/cxiQkSS05ucm3LzrMDEA
ASbWAG9c7uxG8Cbp5blkNy4UxcpeYYKD5WiKKw8ebcIcGicvKTHk5H4PO9l+NSUZ
IcBXXuKr/KWUO35hhNi8lMqTkEVbz1oyIfAO01GRxvnoUJNFvCjYDGSNc9tPVA4b
+IXEsjoyV39WFeIh6daHFfu24ocmHSeKz9oBevx29ooVb8bYN2tnXP8RpH3ER284
4Gumg+HQfB4NgZvp7Yp9m2HLwNImjNg=
-----END PRIVATE KEY-----\0";

pub const EXPIRED_CERT_SUBJECT: &'static str = "CN=ExpiredNode";

pub const EXPIRED_CERT: &'static [u8] = b"-----BEGIN CERTIFICATE-----
MIIEIjCCAgqgAwIBAgIQEp7jjh4EXBbKv6nGmkRH8jANBgkqhkiG9w0BAQsFADAR
MQ8wDQYDVQQDEwZSb290Q0EwHhcNMTkwOTA1MjEwNzQyWhcNMTkwOTA1MjEwODQy
WjAWMRQwEgYDVQQDEwtFeHBpcmVkTm9kZTCCASIwDQYJKoZIhvcNAQEBBQADggEP
ADCCAQoCggEBAOewBNbMSk8Ru6puwowiZtPpEHyIhNfBmPYHMLPciuPNRxajUPDm
0egYk2bHKpXM4AT2o1CHAppZGShUNTy3Hnkbp3Zs3usgrzXyaGWfz4PLPFSIzd0t
ciDdrUGKqqArq+PTqRVtfVpQFX/h1nA2x/1aQmES2Mx4v5vz0K6eMCJjETqSGxWO
ekTMfAsclI3byheyL7A1mXLihBysj/DaclT42qGOxvrWteo3iH+TBFl9pzwVESBV
p5KzVzL0QpEI0eNrkAsMs46HgHgYQeDiM4w5fgGXVphK2oVNfNBWdCjQXr3aq+eL
MEDp2H+LNqzV+6J3e0sLTi6PdukXbqzlyuMCAwEAAaNxMG8wDgYDVR0PAQH/BAQD
AgO4MB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAdBgNVHQ4EFgQURbdm
Cj5LbX98YTpKAwxqWca0dj8wHwYDVR0jBBgwFoAUiS413SfVRGy7vVwkLIGdDA4y
yoswDQYJKoZIhvcNAQELBQADggIBAL2YCL69kSfICx/gRGvQcoChvk5tQ1g8DCpo
JQ0a3GsNW+ACjv/O9CWiYX2mjg/VyO7nMJWDacwVOgr3ckgIwcjpS0MXRDOABcSE
gOxYezgpqEWenYTyNBV/gHkYZcaNXnGp6rCQ6Yz7gIGQ4ExlOEDWwzA7t8PjWCph
jN1+HDUcdJooBr7WyqYuoDYpUTZFZq7chPdYeyXVhhb8A1mMw4MGt/RulrL/hAru
RFvODsq3gdI9XAoollWN1ysdkGqwZrw3TdvFlVCV0MuMS2A2ayveNfjBNVIqfrYu
VK8u2je9c2VIOBxvhD6fGrSNdUDcIfOqG3/bQ81nZ2+MCi1pPPO1gyZzSUg2eRsg
egpasmyFwb84YcUtbZRZFj8lXbiBdbzd+oAmYbw+k3Ki1Efrik7lNG8JDN300Z74
285FYAgtgJzJkClixpQi1AReLAkzNQ2JsNNFBkyRfc8BHEit2iue/QetuEUjv0Vh
WFSG50uK4E2/vRC7eNyQKp2qhcLNwXULVmtwhuyzzG4HzJ6xkko/jbF/wTSFY5py
pWfCK7fWQzgMCbqalMCUsUZsaBNvOIDpA/QZDNVqw/KDlhUSVT+y/rKPwVq/iyjQ
2qQUYwKzYiF2rzeOx3PxlQDKTVA9QDwfFQZb7iu/33n0ahdT2WyeuZ0Cm4Ztqpzb
LigtrEQx
-----END CERTIFICATE-----\0";

pub const EXPIRED_KEY: &'static [u8] = b"-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDnsATWzEpPEbuq
bsKMImbT6RB8iITXwZj2BzCz3IrjzUcWo1Dw5tHoGJNmxyqVzOAE9qNQhwKaWRko
VDU8tx55G6d2bN7rIK818mhln8+DyzxUiM3dLXIg3a1BiqqgK6vj06kVbX1aUBV/
4dZwNsf9WkJhEtjMeL+b89CunjAiYxE6khsVjnpEzHwLHJSN28oXsi+wNZly4oQc
rI/w2nJU+Nqhjsb61rXqN4h/kwRZfac8FREgVaeSs1cy9EKRCNHja5ALDLOOh4B4
GEHg4jOMOX4Bl1aYStqFTXzQVnQo0F692qvnizBA6dh/izas1fuid3tLC04uj3bp
F26s5crjAgMBAAECggEBAKsbqyc77zFgJlojvNij249rlDp01K9HkoE5JDXhjk3Z
YEQOz4tq3OFtrQb91qyVh2kDAfBKFZkKbnMDZeH2V7IXw2DJ3QSHuf68jW9oTGjI
Y0EHXAqaMqylKvy5vXPXbPYwbrKdjzNw67/reWScgKzSyS1KLwUrtE8oDRm5SFFL
svuG3jOiDscXU+WD4fBLECSlZ8gmdHAl8KpQobtylp3s0ApJV9zcwE/yHoafhlr6
/vi5UtLZyE0J3VGYc/5yrPI1Rvv8EO/8g7DCw5yF10AhwO6fuGv0IiuBX2SigNCN
7/Y1DArGoif3hwCUDbsE0SJhsvYYVeUULfRXpJTHj2ECgYEA6fD1g35qvkkObLUw
FLeKuCjCyy9uDlIev6Kk/SEWlCL8ZTo8a59JXYm2mT+shH+o0REQV4BQ6pkRtqev
z/kPBaafIGPwF3S9MnZw0d+3GizbK5Bzj02CI64ZP7W9EzFR212M04Ld1mrl07uf
70dnMUTKy/jThtBSOEJ/d+5BlFMCgYEA/Yiou3AFCgoxGq0orUfVFF4tyVEIeEz8
OujvpoIIu3gjnqBukCceGQEG5/p4MGe+HVsssTmYpKFP80IwPW7WqkrYakBNEcCT
aQ2/eCy+RVSt1rda4sgTYWV5VNNgQ6IDJtTKziuX1cSjIdbVLzrPV9K2s1+tXKLg
SFJkfCfpHTECgYBXF1tvPorimDQEiFeD/uhnstUB64BfWHcWBKjDi6PqNjQcQ1fn
AP/BENmnp6rEEPp6Co445Q46qA2OIFM1a5UKF4O5/TqOoOkmdi1+FHkIB5b4WuiK
euJuAgxoSXJASOYecm9Q9rE7d8Rj1L+vxrdGAkQ1N0cYM0nIpAjsTwie/QKBgQDg
BkI6JXh+b5UGIl2gB6nzbmh8y7p1Omlh0HP6KEp5BGZNAyvO+pGwvGSS1JIhC3pE
zEyIaQFE7zkLFMA1eFv8a1ghQqIW/pgCquA12ythbbqR0MBhRTNCy3xThNc5y82H
IV32oTRv8mnHO+Jx8kBGNO21P+Sax1zw6sTZpBZq8QKBgH5xnIoHv/AxR5wzokBt
C4j3yqL0Gbs+moaswS1UR8XSnKt8TBcXVozCAy12A4qKSjkP7VKPTLeTOZxw0UBe
8CzQYNKoIGy4ayFVi+VKaNCHKvJm0diQkKw5Tz7L5quBBjt8JpmRtNbPsjXiq4Is
y14Xc4kb05mM5M9u685eWefa
-----END PRIVATE KEY-----\0";
use mbedtls::cipher::raw::{Cipher, CipherId, CipherMode};

pub const MAC_LEN: usize = 16;
pub type MacTag = [u8; MAC_LEN];

/// 128-bit AES-CMAC
pub struct Cmac {
    inner: Cipher,
    key: [u8; MAC_LEN],
}

impl Cmac {
    pub fn new(key: &[u8]) -> super::Result<Self> {
        let mut _key = [0u8; MAC_LEN];
        _key.as_mut().clone_from_slice(key);
        Ok(Self {
            inner: Cipher::setup(CipherId::Aes, CipherMode::ECB, (MAC_LEN * 8) as u32)?,
            key: _key,
        })
    }

    pub fn sign(&mut self, data: &[u8]) -> super::Result<MacTag> {
        let mut tag = [0u8; MAC_LEN];
        self.inner.cmac(self.key.as_ref(), data, tag.as_mut())?;
        Ok(tag)
    }

    pub fn sign_len(&mut self, data: &mut [u8], len: usize) -> super::Result<Vec<u8>> {
        let mut tag = [0u8; MAC_LEN];
        let cmac_len = MAC_LEN as usize;
        let mut result = Vec::new();
        let rang = len / cmac_len;
        for _i in 0..rang {
            self.inner.cmac(self.key.as_ref(), data, tag.as_mut())?;
            result.extend_from_slice(&tag);
            self.key[..].clone_from_slice(&tag);
        }
        let fi = len % cmac_len;
        if fi != 0 {
            self.inner.cmac(self.key.as_ref(), data, tag.as_mut())?;
            result.extend_from_slice(&tag[0..fi]);
        }
        Ok(result)
    }

    pub fn verify(&mut self, data: &[u8], tag: &MacTag) -> super::Result<()> {
        let ref_tag = self.sign(data)?;
        match &ref_tag == tag {
            true => Ok(()),
            false => Err(super::error::CryptoError::CmacVerificationError),
        }
    }
}
use mbedtls::hash;

const SHA256DIGEST_LEN: usize = 32;
pub const SHA256_TYPE: hash::Type = hash::Type::Sha256;
pub type Sha256Digest = [u8; SHA256DIGEST_LEN];

pub fn sha256(data: &[u8]) -> super::Result<Sha256Digest> {
    let mut digest = [0u8; SHA256DIGEST_LEN];
    hash::Md::hash(SHA256_TYPE, data, &mut digest[..])?;
    Ok(digest)
}
// pub use mbedtls::rng::EntropyCallback;

#[cfg(not(target_env = "sgx"))]
use std::sync::Arc;

cfg_if::cfg_if! {
    if #[cfg(any(feature = "rdrand", target_env = "sgx"))] {
        pub fn entropy_new() -> mbedtls::rng::Rdseed {
            mbedtls::rng::Rdseed
        }
    } else if #[cfg(feature = "std")] {
        pub fn entropy_new() -> crate::mbedtls::rng::OsEntropy {
            crate::mbedtls::rng::OsEntropy::new()
        }
    } else {
        pub fn entropy_new() -> ! {
            panic!("Unable to run test without entropy source")
        }
    }
}


#[cfg(target_env = "sgx")]
pub struct Rng {
    pub inner: mbedtls::rng::Rdrand,
}

#[cfg(not(target_env = "sgx"))]
pub struct Rng {
    pub inner: mbedtls::rng::CtrDrbg,
}

#[cfg(target_env = "sgx")]
impl Rng {
    pub fn new() -> Self {
        Self {
            inner: mbedtls::rng::Rdrand,
        }
    }
}

#[cfg(not(target_env = "sgx"))]
impl Rng {
    pub fn new() -> Self {
        let entropy = Arc::new(mbedtls::rng::OsEntropy::new());
        Self {
            inner: mbedtls::rng::CtrDrbg::new(entropy, None).unwrap(),
        }
    }
}
pub mod aes_gcm;
pub mod certificate;
pub mod cmac;
pub mod digest;
pub mod error;
pub mod key_exchange;
pub mod random;
pub mod signature;
pub mod tls_psk;
pub mod keys;
pub type Result<T> = std::result::Result<T, error::CryptoError>;

extern crate cfg_if;use std::io;

#[derive(Debug)]
pub enum CryptoError {
    MbedTls(mbedtls::Error),
    Io(io::Error),
    CmacVerificationError,
}

impl std::convert::From<mbedtls::Error> for CryptoError {
    fn from(e: mbedtls::Error) -> Self {
        Self::MbedTls(e)
    }
}

impl std::convert::From<io::Error> for CryptoError {
    fn from(e: io::Error) -> Self {
        Self::Io(e)
    }
}
use super::digest::{sha256, SHA256_TYPE};
use super::random::Rng;
use mbedtls::ecp::{EcGroup, EcPoint};
use mbedtls::pk::{EcGroupId, Pk, ECDSA_MAX_LEN};
use std::fs::File;
use std::io::Read;
use std::path::Path;

pub type ECDSAPublicKey = Vec<u8>;
pub type Signature = Vec<u8>;
const ECGROUP_ID: EcGroupId = EcGroupId::SecP256K1;
pub struct VerificationKey {
    inner: Pk,
}

impl VerificationKey {
    /// Takes both DER and PEM forms of PKCS#1 or PKCS#8 encoded keys.
    /// When calling on PEM-encoded data, key must be NULL-terminated
    pub fn new(public_key: &[u8]) -> super::Result<Self> {
        let inner = Pk::from_public_key(public_key)?;
        Ok(Self { inner })
    }
    pub fn new_from_binary(public_key: &[u8]) -> super::Result<Self> {
        let secp256k1 = EcGroup::new(ECGROUP_ID).unwrap();
        let rec_pt = EcPoint::from_binary(&secp256k1, &public_key).unwrap();
        let inner = Pk::public_from_ec_components(secp256k1, rec_pt).unwrap();
        Ok(Self { inner })
    }

    /// Takes both DER and PEM forms of PKCS#1 or PKCS#8 encoded keys.
    pub fn new_from_file(public_key_path: &Path) -> super::Result<Self> {
        let mut file = File::open(public_key_path)?;
        let mut buf = Vec::new();
        file.read_to_end(&mut buf)?;
        if public_key_path.extension().unwrap() == "pem" {
            buf.push(0);
        }
        Self::new(&buf[..])
    }

    pub fn verify(&mut self, message: &[u8], signature: &[u8]) -> super::Result<()> {
        let hash = sha256(message)?;
        self.inner.verify(SHA256_TYPE, &hash[..], signature)?;
        Ok(())
    }
}

pub struct SigningKey {
    inner: Pk,
}
impl SigningKey {
    /// Takes both DER and PEM forms of PKCS#1 or PKCS#8 encoded keys.
    /// When calling on PEM-encoded data, key must be NULL-terminated
    pub fn new(private_key: &[u8], password: Option<&[u8]>) -> super::Result<Self> {
        let inner = Pk::from_private_key(private_key, password)?;
        Ok(Self { inner })
    }
    pub fn generate_keypair(rng: &mut Rng) -> super::Result<Self> {
        Ok(Self {
            inner: Pk::generate_ec(&mut rng.inner, ECGROUP_ID)?,
        })
    }

    pub fn get_public_key(&self) -> super::Result<ECDSAPublicKey> {
        let ecgroup = self.inner.ec_group()?;
        Ok(self.inner.ec_public()?.to_binary(&ecgroup, true)?)
    }
    /// Takes both DER and PEM forms of PKCS#1 or PKCS#8 encoded keys.
    pub fn new_from_file(private_key_path: &Path, password: Option<&[u8]>) -> super::Result<Self> {
        let mut file = File::open(private_key_path)?;
        let mut buf = Vec::new();
        file.read_to_end(&mut buf)?;
        if private_key_path.extension().unwrap() == "pem" {
            buf.push(0);
        }
        Self::new(&buf[..], password)
    }

    pub fn sign(&mut self, message: &[u8], rng: &mut Rng) -> super::Result<Signature> {
        let hash = sha256(message)?;
        let sig_len = self.inner.rsa_public_modulus()?.byte_length()?;
        let mut signature = vec![0u8; sig_len];
        self.inner
            .sign(SHA256_TYPE, &hash[..], &mut signature[..], &mut rng.inner)?;
        Ok(signature)
    }
    pub fn ecdsa_sign(&mut self, message: &[u8], rng: &mut Rng) -> super::Result<Signature> {
        let hash = sha256(message)?;
        let sig_len = ECDSA_MAX_LEN;
        let mut signature = vec![0u8; sig_len];
        let len = self.inner.sign_deterministic(
            SHA256_TYPE,
            &hash[..],
            &mut signature[..],
            &mut rng.inner,
        )?;
        //Ok(signature)
        Ok(signature[..len].to_vec())
    }
}
use mbedtls::cipher::raw::{Cipher, CipherId, CipherMode, Operation::Encrypt};

pub const MAC_LEN: usize = 16;
pub type MacTag = [u8; MAC_LEN];

/// 256-bit AES-GCM
pub struct AESGCM {
    inner: Cipher,
}

impl AESGCM {
    // default key len == 32 bytes
    pub fn new() -> super::Result<Self> {
        // _key.as_mut().clone_from_slice(key);
        Ok(Self {
            inner: Cipher::setup(CipherId::Aes, CipherMode::GCM, (32 * 8) as u32)?,
        })
    }
    pub fn new_with_key(key: &[u8], key_len: u32) -> super::Result<Self> {
        // _key.as_mut().clone_from_slice(key);
        if key_len != 16 && key_len != 24 && key_len != 32 {
            panic!("error key len for aes gcm mode");
        }
        let mut inner = Cipher::setup(CipherId::Aes, CipherMode::GCM, (key_len * 8) as u32)
            .expect("Cipher::setup error");
        // inner.set_key_and_maybe_iv(key, None)?;
        inner.set_key(Encrypt, key).expect("Cipher::set_key error");
        let iv = [0u8; 16];
        inner.set_iv(&iv).expect("Cipher::set_iv error");
        inner.reset()?;
        Ok(Self { inner })
    }
    pub fn set_key_iv(&mut self, key: &[u8], iv: &[u8]) -> super::Result<()> {
        // self.inner.set_key_and_maybe_iv(key, Some(iv))?;
        self.inner.set_key(Encrypt, key)?;
        self.inner.set_iv(iv)?;
        self.inner.reset()?;
        Ok(())
    }
    pub fn encrypt(
        &mut self,
        plain_text: &[u8],
        cipher_and_tag: &mut [u8],
        tag_len: usize,
    ) -> super::Result<usize> {
        let ad = [0u8, 0, 0, 0];
        // let cipher_and_tag = cipher_text. + &tag;
        let len = self
            .inner
            .encrypt_auth(&ad, plain_text, cipher_and_tag, tag_len)
            .expect("Cipher::encrypt_auth");
        Ok(len)
    }

    pub fn decrypt(
        &mut self,
        cipher_text_and_tag: &[u8],
        plain_text: &mut [u8],
        tag_len: usize,
    ) -> super::Result<usize> {
        let ad = [0u8, 0, 0, 0];
        Ok(self.inner.decrypt_auth(&ad, cipher_text_and_tag, plain_text, tag_len)?)
    }
}
use super::cmac::{Cmac, MAC_LEN};
use super::random::Rng;
use super::signature::{Signature, SigningKey, VerificationKey};
use mbedtls::ecp::EcPoint;
use mbedtls::pk::{EcGroupId, Pk};
use std::io::Write;

const ECGROUP_ID: EcGroupId = EcGroupId::SecP256R1;
const SECRET_SHARE_LEN: usize = 32;
pub type DHKEPublicKey = Vec<u8>;
pub type KDK = [u8; MAC_LEN];

pub struct DHKE {
    inner: Pk,
}

impl DHKE {
    pub fn generate_keypair(rng: &mut Rng) -> super::Result<Self> {
        Ok(Self {
            inner: Pk::generate_ec(&mut (rng.inner), ECGROUP_ID)?,
        })
    }

    pub fn get_public_key(&self) -> super::Result<DHKEPublicKey> {
        let ecgroup = self.inner.ec_group()?;
        Ok(self.inner.ec_public()?.to_binary(&ecgroup, true)?)
    }

    /// RNG is used to implement countermeasures against side-channel attacks. See https://tls.mbed.org/api/ecdh_8h.html#a423fee27a0c8603bba336cbfe6dadcaa
    pub fn derive_key(
        mut self,
        peer_public_key: &DHKEPublicKey,
        rng: &mut Rng,
    ) -> super::Result<KDK> {
        let mut ikm = vec![0; SECRET_SHARE_LEN];
        let ecgroup = self.inner.ec_group()?;
        let peer_public_key = Pk::public_from_ec_components(
            ecgroup.clone(),
            EcPoint::from_binary(&ecgroup, &peer_public_key[..])?,
        )?;
        let len = self
            .inner
            .agree(&peer_public_key, &mut ikm[..], &mut rng.inner)?;
        assert_eq!(len, SECRET_SHARE_LEN);
        let cmac_key = [0u8; MAC_LEN];
        let mut kdf = Cmac::new(&cmac_key[..])?;
        let out = kdf.sign(&ikm[..])?;
        Ok(out)
    }
    /// diff from derive_key, this method can generate any len key for neccessry
    pub fn derive_key_len(
        mut self,
        peer_public_key: &DHKEPublicKey,
        rng: &mut Rng,
        key_len: usize,
    ) -> super::Result<Vec<u8>> {
        let mut ikm = vec![0; SECRET_SHARE_LEN];
        let ecgroup = self.inner.ec_group()?;
        let peer_public_key = Pk::public_from_ec_components(
            ecgroup.clone(),
            EcPoint::from_binary(&ecgroup, &peer_public_key[..])?,
        )?;
        let len = self
            .inner
            .agree(&peer_public_key, &mut ikm[..], &mut rng.inner)?;
        assert_eq!(len, SECRET_SHARE_LEN);
        let cmac_key = [0u8; MAC_LEN];
        let mut kdf = Cmac::new(&cmac_key[..])?;
        let out = kdf.sign_len(&mut ikm[..], key_len)?;
        Ok(out)
    }
}

/// One-way authenticated DHKE. Alice (g_a) verifies and Bob (g_b) signs.
pub struct OneWayAuthenticatedDHKE {
    inner: DHKE,
}

impl OneWayAuthenticatedDHKE {
    pub fn generate_keypair(rng: &mut Rng) -> super::Result<Self> {
        let inner = DHKE::generate_keypair(rng)?;
        Ok(Self { inner })
    }

    pub fn get_public_key(&self) -> super::Result<DHKEPublicKey> {
        self.inner.get_public_key()
    }

    /// Bob signs the (g_b, g_a).
    pub fn sign_and_derive(
        self,
        g_a: &DHKEPublicKey,
        signing_key: &mut SigningKey,
        rng: &mut Rng,
    ) -> super::Result<(KDK, Signature)> {
        // Sign (g_b, g_a) with Bob's signing key
        let mut gb_ga = Vec::new();
        gb_ga.write_all(&self.inner.get_public_key()?).unwrap();
        gb_ga.write_all(g_a).unwrap();
        let sign_gb_ga = signing_key.sign(&gb_ga[..], rng)?;

        // Derive KDK
        let kdk = self.inner.derive_key(g_a, rng)?;
        Ok((kdk, sign_gb_ga))
    }

    /// Alice verifies the (g_b, g_a).
    pub fn verify_and_derive(
        self,
        g_b: &DHKEPublicKey,
        sign_gb_ga: &Signature,
        verification_key: &mut VerificationKey,
        rng: &mut Rng,
    ) -> super::Result<KDK> {
        // Verify (g_b, g_a) with Bob's verification key
        let mut gb_ga = Vec::new();
        gb_ga.write_all(g_b).unwrap();
        gb_ga.write_all(&self.inner.get_public_key()?).unwrap();
        verification_key.verify(&gb_ga[..], &sign_gb_ga[..])?;

        // Derive KDK
        self.inner.derive_key(g_b, rng)
    }
}
use super::digest::{sha256, SHA256_TYPE};
use mbedtls::alloc::{List as MbedtlsList, Box as MbedtlsBox};
use mbedtls::x509::Certificate;
use std::fs::File;
use std::io::Read;
use std::path::Path;

#[derive(Debug)]
pub struct X509Cert {
    inner: MbedtlsBox<Certificate>,
}

impl X509Cert {
    pub fn new_from_der(x509_der: &[u8]) -> super::Result<Self> {
        let inner = Certificate::from_der(x509_der).unwrap();
        Ok(Self { inner })
    }

    /// Input must be NULL-terminated
    pub fn new_from_pem(x509_pem: &[u8]) -> super::Result<Self> {
        let inner = Certificate::from_pem(x509_pem).unwrap();
        Ok(Self { inner })
    }

    pub fn new_from_der_file(x509_der_path: &Path) -> super::Result<Self> {
        let mut file = File::open(x509_der_path)?;
        let mut buf = Vec::new();
        file.read_to_end(&mut buf)?;
        Self::new_from_pem(&buf[..])
    }

    pub fn new_from_pem_file(x509_pem_path: &Path) -> super::Result<Self> {
        let mut file = File::open(x509_pem_path)?;
        let mut buf = Vec::new();
        file.read_to_end(&mut buf)?;
        buf.push(0);
        Self::new_from_pem(&buf[..])
    }

    pub fn verify_this_certificate(&mut self, trust_ca: &mut Self) -> super::Result<()> {
        // self.inner.verify(&mut trust_ca.inner, None)?;
        let mut chain = MbedtlsList::<Certificate>::new();
        chain.push(self.inner.clone());
        let mut ca_chain = MbedtlsList::<Certificate>::new();
        ca_chain.push(trust_ca.inner.clone());
        let err = Certificate::verify(&chain, &mut ca_chain, None);
        match err.as_ref() {
            Err(e) => eprintln!("Certificate verify failed : {:#?} !", e),
            Ok(_v) => eprintln!("Certificate verify successfully !")
        }        
        Ok(())
    }

    pub fn verify_signature(&mut self, message: &[u8], signature: &[u8]) -> super::Result<()> {
        let hash = sha256(message)?;
        self.inner
            .public_key_mut()
            .verify(SHA256_TYPE, &hash[..], signature)?;
        Ok(())
    }
}

impl PartialEq for X509Cert {
    fn eq(&self, other: &Self) -> bool {
        self.inner.as_der() == other.inner.as_der()
    }
}
use mbedtls::ssl::config::{Endpoint, Preset, Transport};
use mbedtls::ssl::{Config, Context, HandshakeContext};
use mbedtls::Result;
use std::sync::Arc;
use super::random::Rng;

type Callback = Box<dyn FnMut(&mut HandshakeContext, &str) -> Result<()>>;

pub mod server {
    use super::*;
    pub fn callback(psk: &[u8]) -> Callback {
        let psk = psk.to_owned();
        Box::new(move |ctx: &mut HandshakeContext, _: &str| ctx.set_psk(psk.as_ref()))
    }

    pub fn config(rng: Rng, callback: &mut Callback) -> Config {
        let mut config = Config::new(Endpoint::Server, Transport::Stream, Preset::Default);
        config.set_rng(Arc::new(rng.inner));
        config.set_psk_callback(callback);
        config
    }

    pub fn context(config: Arc<Config>) -> Context {
        Context::new(config)
    }
}

pub mod client {
    use super::*;

    pub fn config(rng: Rng, psk: &[u8]) -> Result<Config> {
        let mut config = Config::new(Endpoint::Client, Transport::Stream, Preset::Default);
        config.set_rng(Arc::new(rng.inner));
        config.set_psk(psk, "Client_identity")?;
        Ok(config)
    }

    pub fn context(config: Arc<Config>) -> Context {
        Context::new(config)
    }
}
use byteorder::{LittleEndian, WriteBytesExt};
use serde::{Deserialize, Serialize};
use serde_big_array::big_array;
use sgx_crypto::cmac::{Cmac, MacTag};
use sgx_crypto::error::CryptoError;
use sgx_crypto::key_exchange::DHKEPublicKey;
use sgx_crypto::signature::Signature;
use std::io::Write;
use std::mem::size_of;

pub type Gid = [u8; 4];
pub type Spid = [u8; 16];
pub type PsSecPropDesc = [u8; 256];
pub type Quote = [u8; 1116]; // 436 + quote.signature_len for version 2

big_array! {
    BigArray;
    +size_of::<Quote>(),
}

#[derive(Serialize, Deserialize, Debug)]
pub struct RaMsg0 {
    pub exgid: u32,
}

#[derive(Serialize, Deserialize)]
pub struct RaMsg1 {
    pub gid: Gid,
    pub g_a: DHKEPublicKey,
}

#[derive(Serialize, Deserialize)]
pub struct RaMsg2 {
    pub g_b: DHKEPublicKey,
    pub spid: Spid,
    pub quote_type: u16, /* unlinkable Quote(0) or linkable Quote(1) */
    pub sign_gb_ga: Signature,
    pub mac: MacTag,
    pub sig_rl: Option<Vec<u8>>,
}

impl RaMsg2 {
    pub fn new(
        smk: &mut Cmac,
        g_b: DHKEPublicKey,
        spid: Spid,
        quote_type: u16,
        sign_gb_ga: Signature,
        sig_rl: Option<Vec<u8>>,
    ) -> Result<Self, CryptoError> {
        let mut msg2 = Self {
            g_b,
            spid,
            quote_type,
            sign_gb_ga,
            mac: [0u8; size_of::<MacTag>()],
            sig_rl,
        };
        let a = msg2.get_a();
        msg2.mac = smk.sign(&a[..])?;
        Ok(msg2)
    }

    pub fn verify_mac(&self, smk: &mut Cmac) -> Result<(), CryptoError> {
        let a = self.get_a();
        smk.verify(&a[..], &self.mac)
    }

    fn get_a(&self) -> Vec<u8> {
        let mut a = Vec::new();
        a.write_all(&self.g_b[..]).unwrap();
        a.write_all(&self.spid[..]).unwrap();
        a.write_u16::<LittleEndian>(self.quote_type).unwrap();
        a.write_all(&self.sign_gb_ga[..]).unwrap();
        a
    }
}

#[derive(Serialize, Deserialize)]
pub struct PsSecPropDescInternal {
    #[serde(with = "BigArray")]
    pub inner: PsSecPropDesc,
}

#[derive(Serialize, Deserialize)]
pub struct RaMsg3 {
    pub mac: MacTag,
    pub g_a: DHKEPublicKey,
    pub ps_sec_prop: Option<PsSecPropDescInternal>,
    #[serde(with = "BigArray")]
    pub quote: Quote,
}

impl RaMsg3 {
    pub fn new(
        smk: &mut Cmac,
        g_a: DHKEPublicKey,
        ps_sec_prop: Option<PsSecPropDesc>,
        quote: Quote,
    ) -> Result<Self, CryptoError> {
        let ps_sec_prop = ps_sec_prop.map(|v| PsSecPropDescInternal { inner: v });
        let mut msg3 = Self {
            mac: [0u8; size_of::<MacTag>()],
            g_a,
            ps_sec_prop,
            quote,
        };
        let m = msg3.get_m();
        msg3.mac = smk.sign(&m[..])?;
        Ok(msg3)
    }

    pub fn verify_mac(&self, smk: &mut Cmac) -> Result<(), CryptoError> {
        let m = self.get_m();
        smk.verify(&m[..], &self.mac)
    }

    fn get_m(&self) -> Vec<u8> {
        let mut m = Vec::new();
        m.write_all(&self.g_a[..]).unwrap();
        if self.ps_sec_prop.is_some() {
            m.write_all(&self.ps_sec_prop.as_ref().unwrap().inner[..])
                .unwrap();
        }
        m.write_all(&self.quote[..]).unwrap();
        m
    }
}

#[derive(Serialize, Deserialize, Debug)]
pub struct RaMsg4 {
    pub is_enclave_trusted: bool,
    pub is_pse_manifest_trusted: Option<bool>,
    pub pib: Option<String>,
}
pub mod msg;
pub mod tcp;

use sgx_crypto::cmac::{Cmac, MacTag};
use sgx_crypto::error::CryptoError;
/// Derive SMK, SK, MK, and VK according to
/// https://software.intel.com/en-us/articles/code-sample-intel-software-guard-extensions-remote-attestation-end-to-end-example
pub fn derive_secret_keys(kdk: &mut Cmac) -> Result<(MacTag, MacTag, MacTag, MacTag), CryptoError> {
    let smk_data = [0x01, 'S' as u8, 'M' as u8, 'K' as u8, 0x00, 0x80, 0x00];
    let smk = kdk.sign(&smk_data)?;

    let sk_data = [0x01, 'S' as u8, 'K' as u8, 0x00, 0x80, 0x00];
    let sk = kdk.sign(&sk_data)?;

    let mk_data = [0x01, 'M' as u8, 'K' as u8, 0x00, 0x80, 0x00];
    let mk = kdk.sign(&mk_data)?;

    let vk_data = [0x01, 'V' as u8, 'K' as u8, 0x00, 0x80, 0x00];
    let vk = kdk.sign(&vk_data)?;

    Ok((smk, sk, mk, vk))
}
use std::io::{Error, ErrorKind, Result};
use std::net::{TcpListener, TcpStream};
use std::thread::sleep;
use std::time::{Duration, Instant};

const CONNECT_SLEEP_TIME_MILLIS: u64 = 10;

pub fn tcp_connect(addr: &str, timeout: Duration) -> Result<TcpStream> {
    let start = Instant::now();
    loop {
        match TcpStream::connect(addr) {
            Ok(s) => {
                return Ok(s);
            }
            Err(e) => {
                if start.elapsed() == timeout {
                    return Err(Error::new(ErrorKind::TimedOut, e));
                }
            }
        }
        sleep(Duration::from_millis(CONNECT_SLEEP_TIME_MILLIS));
    }
}

pub fn tcp_accept(addr: &str) -> Result<TcpStream> {
    let listener = TcpListener::bind(addr)?;
    Ok(listener.accept()?.0)
}
### build.sh
TARGET_NAME=sgx-task-enclave
TARGET_DIR=`pwd`/sgx-task-enclave/target/x86_64-fortanix-unknown-sgx/debug
TARGET=$TARGET_DIR/$TARGET_NAME
TARGET_SGX=$TARGET_DIR/$TARGET_NAME.sgxs
TARGET_SIG=$TARGET_DIR/$TARGET_NAME.sig
KEY=ra-enclave/examples/data/vendor-keys/private_key.pem

# Build and sign enclave
(cd sgx-task-enclave && cargo build --target x86_64-fortanix-unknown-sgx ) && \
ftxsgx-elf2sgxs $TARGET --heap-size 0x2000000 --stack-size 0x20000 --threads 8 \
    --debug --output $TARGET_SGX && \
#sgxs-sign --key $KEY $TARGET_SGX $TARGET_DIR/$TARGET_NAME.sig -d --xfrm 7/0 --isvprodid 0 --isvsvn 0
sgxs-sign --key $KEY $TARGET_SGX $TARGET_SIG -d --xfrm 7/0 --isvprodid 0 --isvsvn 0extern crate clap;

use byteorder::{NetworkEndian, WriteBytesExt}; 
use attest_client::ClientRaContext;
use ra_common::tcp::tcp_connect;
use std::time::Duration;
use std::io::Write;
use clap::App;

fn main() {
    let matches = App::new("attest-client")
                .version("1.0")
                .author("simplelin. ")
                .about("Do remote attestation")
                .args_from_usage(
                    "-e   --enclave=[String] 'Sets IP and Port for enclave,such as: \"127.0.0.1:7777\"'
                    -s   --server=[String] 'Sets IP and Port for service provide,such as: \"192.168.1.1:1234\"'
                    -n   --number=[u8]     'Serial number for the enclave that will send quote to client,\"0-255\".such as:0' ")
                .get_matches();
    let enclave  = matches.value_of("enclave").unwrap_or("127.0.0.1:7777");
    let service  = matches.value_of("server").unwrap_or("127.0.0.1:1234");
    let number  = matches.value_of("number").unwrap_or("0");//.as_bytes();
    let number  = number.parse::<u8>().expect("the input value is invalid,that should be a id and type is \"u8\"");
    let timeout = Duration::from_secs(5);
    let mut enclave_stream =
        tcp_connect(enclave, timeout).expect("Client: Enclave connection failed");
    eprintln!("Client: connected to enclave {:?}.", enclave);

    let mut sp_stream =
        tcp_connect(service, timeout).expect("Client: SP connection failed");
    eprintln!("Client: connected to SP {:?}.", service);
    sp_stream.write_u8(number).unwrap();
    let context = ClientRaContext::init().unwrap();
    context
        .do_attestation(&mut enclave_stream, &mut sp_stream)
        .unwrap();
    let msg = "127.0.0.1:3333";
    sp_stream.write_u32::<NetworkEndian>(msg.len() as u32).unwrap();
    //write!(&mut sp_stream, "{}", msg).unwrap();
    sp_stream.write(msg.as_bytes()).unwrap();
    eprintln!("Client: done!");
}
use crate::error::ClientRaError;
use crate::ClientRaResult;
use aesm_client::{AesmClient, QuoteInfo};
use ra_common::msg::{Gid, Quote, RaMsg0, RaMsg1, RaMsg2, RaMsg3, RaMsg4};
use sgx_crypto::cmac::MacTag;
use sgx_crypto::key_exchange::DHKEPublicKey;
use sgx_isa::Report;
use std::convert::TryInto;
use std::io::{Read, Write};
use std::mem::size_of;

pub struct ClientRaContext {
    pub ctx_aesm_client: AesmClient,
    pub quote_info: QuoteInfo,
    pub g_a: Option<DHKEPublicKey>,
}

impl ClientRaContext {
    pub fn init() -> ClientRaResult<Self> {
        let ctx_aesm_client = AesmClient::new();
        let quote_info = ctx_aesm_client.init_quote()?;
        Ok(Self {
            ctx_aesm_client,
            quote_info,
            g_a: None,
        })
    }

    pub fn do_attestation(
        mut self,
        mut enclave_stream: &mut (impl Read + Write),
        mut sp_stream: &mut (impl Read + Write),
    ) -> ClientRaResult<()> {
        let msg0 = self.get_extended_epid_group_id();
        if cfg!(feature = "verbose") {
            eprintln!("MSG0 generated");
        }

        bincode::serialize_into(&mut sp_stream, &msg0)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG0 sent");
        }

        let msg1 = self.get_msg_1(enclave_stream);
        if cfg!(feature = "verbose") {
            eprintln!("MSG1 generated");
        }

        bincode::serialize_into(&mut sp_stream, &msg1)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG1 sent");
        }

        let msg2: RaMsg2 = bincode::deserialize_from(&mut sp_stream)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG2 received");
        }

        let msg3 = self.process_msg_2(msg2, enclave_stream)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG3 generated");
        }

        bincode::serialize_into(&mut sp_stream, &msg3)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG3 sent");
        }

        let msg4: RaMsg4 = bincode::deserialize_from(&mut sp_stream)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG4 received");
        }

        bincode::serialize_into(&mut enclave_stream, &msg4).unwrap();

        if !msg4.is_enclave_trusted {
            return Err(ClientRaError::EnclaveNotTrusted);
        }
        match msg4.is_pse_manifest_trusted {
            Some(t) => {
                if !t {
                    return Err(ClientRaError::PseNotTrusted);
                }
            }
            None => {}
        }
        Ok(())
    }

    /// ExGID = 0 means IAS will be used for remote attestation. This function only
    /// returns 0 for now.
    pub fn get_extended_epid_group_id(&self) -> RaMsg0 {
        RaMsg0 { exgid: 0 }
    }

    pub fn get_msg_1(&mut self, enclave_stream: &mut (impl Read + Write)) -> RaMsg1 {
        let g_a: DHKEPublicKey = bincode::deserialize_from(enclave_stream).unwrap();
        let gid: Gid = self.quote_info.gid().try_into().unwrap();
        self.g_a = Some(g_a.clone());
        RaMsg1 { gid, g_a }
    }

    pub fn process_msg_2(
        &mut self,
        msg2: RaMsg2,
        mut enclave_stream: &mut (impl Read + Write),
    ) -> ClientRaResult<RaMsg3> {
        bincode::serialize_into(&mut enclave_stream, &msg2).unwrap();

        let sig_rl = match msg2.sig_rl {
            Some(sig_rl) => sig_rl.to_owned(),
            None => Vec::with_capacity(0),
        };
        let spid = (&msg2.spid[..]).to_owned();

        // Get a Quote and send it to enclave to sign
        let quote = Self::get_quote(&self.ctx_aesm_client, spid, sig_rl, enclave_stream)?;

        // Read MAC for msg3 from enclave
        let mut mac = [0u8; size_of::<MacTag>()];
        enclave_stream.read_exact(&mut mac).unwrap();

        Ok(RaMsg3 {
            g_a: self.g_a.take().unwrap(),
            mac,
            ps_sec_prop: None,
            quote,
        })
    }

    /// Get a Quote and send it to enclave to sign
    pub fn get_quote(
        aesm_client: &AesmClient,
        spid: Vec<u8>,
        sig_rl: Vec<u8>,
        enclave_stream: &mut (impl Read + Write),
    ) -> ClientRaResult<Quote> {
        let quote_info = aesm_client.init_quote()?;

        // Get report for local attestation with QE from enclave
        enclave_stream.write_all(quote_info.target_info()).unwrap();
        let mut report = vec![0u8; Report::UNPADDED_SIZE];
        enclave_stream.read_exact(&mut report[..]).unwrap();

        // Get a quote and QE report from QE and send them to enclave
        let _quote = aesm_client.get_quote(&quote_info, report, spid, sig_rl)?;
        enclave_stream.write_all(_quote.quote()).unwrap();
        enclave_stream.write_all(_quote.qe_report()).unwrap();

        let mut quote = [0u8; size_of::<Quote>()];
        quote.copy_from_slice(_quote.quote());
        Ok(quote)
    }
}
mod context;
mod error;

pub use crate::context::*;
pub use crate::error::*;

pub type ClientRaResult<T> = Result<T, ClientRaError>;
#[derive(Debug)]
pub enum ClientRaError {
    IO(std::boxed::Box<bincode::ErrorKind>),
    Aesm(aesm_client::Error),
    EnclaveNotTrusted,
    PseNotTrusted,
}

impl std::convert::From<aesm_client::Error> for ClientRaError {
    fn from(e: aesm_client::Error) -> Self {
        Self::Aesm(e)
    }
}

impl std::convert::From<std::boxed::Box<bincode::ErrorKind>> for ClientRaError {
    fn from(e: std::boxed::Box<bincode::ErrorKind>) -> Self {
        Self::IO(e)
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

extern crate byteorder;
extern crate mbedtls;
extern crate ndarray;
extern crate rand;
extern crate tvm_graph_rt;

use byteorder::{NetworkEndian, WriteBytesExt};
use std::net::TcpListener;
//use std::io::Write;
use mbedtls::pk::Pk;
// use mbedtls::rng::CtrDrbg;
use mbedtls::ssl::config::{Endpoint, Preset, Transport};
use mbedtls::ssl::{Config, Context};
use mbedtls::x509::Certificate;
use ra_enclave::tls_enclave::attestation;
use sgx_crypto::random::Rng;
use ra_enclave::context::EnclaveRaContext;
use std::convert::TryInto;
use sgx_crypto::keys;

use serde_json::Value;

use std::{
    convert::TryFrom as _,
    sync::Arc,
    io::{BufReader, Read, Write},
    // thread,
    time::{SystemTime, UNIX_EPOCH},
};
//use ndarray::{Array, Array4};

fn timestamp() -> i64 {
    let start = SystemTime::now();
    let since_the_epoch = start
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards");
    let ms = since_the_epoch.as_secs() as i64 * 1000i64
        + (since_the_epoch.subsec_nanos() as f64 / 1_000_000.0) as i64;
    ms
}

fn main() {
    // let mut thread_vec = vec![];
    // let handle = thread::spawn(move || {
    println!("Attestation start ...");
    let config = include_str!(concat!(env!("PWD"), "/config"));
    let config: Value = serde_json::from_str(config).unwrap();
    let client_address = config["client_address"].as_str().unwrap();
    let sp_address = config["sp_address"].as_str().unwrap();
    let mut enclave_racontext = attestation(client_address, sp_address, keep_message).unwrap();
    println!("Attestation end!");
    println!("do tvm start ...");
    do_tvm(&mut enclave_racontext);
    println!("do tvm end!");
    // });
    
    // thread_vec.push(handle);
    // let handle = thread::spawn(move || {
    //     do_tvm();
    // });
    // thread_vec.push(handle);
    // for handle in thread_vec {
    //     // Wait for the thread to finish. Returns a result.
    //     let _ = handle.join().unwrap();
    // }
}

pub fn keep_message(session: BufReader<mbedtls::ssl::Context>) {
    let mut sess = session;
    let msg = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque non placerat risus, et lobortis quam. Mauris velit lorem, elementum id neque a, aliquet tempus turpis. Nam eu congue urna, in semper quam. Ut tristique gravida nunc nec feugiat. Proin tincidunt massa a arcu volutpat, sagittis dignissim velit convallis. Cras ac finibus lorem, nec congue felis. Pellentesque fermentum vitae ipsum sed gravida. Nulla consectetur sit amet erat a pellentesque. Donec non velit sem. Sed eu metus felis. Nullam efficitur consequat ante, ut commodo nisi pharetra consequat. Ut accumsan eget ligula laoreet dictum. Maecenas tristique porta convallis. Suspendisse tempor sodales velit, ac luctus urna varius eu. Ut ultrices urna vestibulum vestibulum euismod. Vivamus eu sapien urna.";
    sess.get_mut().write_u32::<NetworkEndian>(msg.len() as u32).unwrap();
    write!(&mut sess.get_mut(), "{}", msg).unwrap();
}

pub fn do_tvm(racontext: &mut EnclaveRaContext) {
    let config = include_str!(concat!(env!("PWD"), "/config"));
    let config: Value = serde_json::from_str(config).unwrap();
    let server_address = config["server_address"].as_str().unwrap();
    //let client_address = config[3];
    let syslib = tvm_graph_rt::SystemLibModule::default();
    let graph_json = include_str!(concat!(env!("OUT_DIR"), "/graph.json"));
    let params_bytes = include_bytes!(concat!(env!("OUT_DIR"), "/params.bin"));
    let params = tvm_graph_rt::load_param_dict(params_bytes).unwrap();

    let graph = tvm_graph_rt::Graph::try_from(graph_json).unwrap();
    let mut exec = tvm_graph_rt::GraphExecutor::new(graph, &syslib).unwrap();
    exec.load_params(params);
    let listener = TcpListener::bind(server_address).unwrap();
    println!("TVM run: listening at {}", server_address);
    for stream in listener.incoming() {
        let mut stream = stream.unwrap();

        //to verify the quote and private key
        let signer_key = &mut racontext.signer_key;
        //read rand data from user
        let mut rand_data = vec![0u8; 64];
        let mut rng =Rng::new();
        stream.read_exact(&mut rand_data).unwrap();
        let sign_data = signer_key.ecdsa_sign(& rand_data,&mut rng).expect("Error when signing the user rang data!");        
        stream.write_u32::<NetworkEndian>(sign_data.len().try_into().unwrap()).unwrap();
        stream.write_all(racontext.quote.as_ref()).unwrap();
        stream.write_all(sign_data.as_ref()).unwrap();
        
        let mut verify_data = [0u8; 4];
        stream.read_exact(&mut verify_data).unwrap();
        if verify_data != [1u8;4]{
            eprintln!("an error occured when user verify the quote and sign!");
            continue;
        }
        let mut verify_data = [0u8; 4];
        stream.read_exact(&mut verify_data).unwrap();
        continue;
        let mut config = Config::new(Endpoint::Server, Transport::Stream, Preset::Default);
        let rng = Rng::new();
        config.set_rng(Arc::new(rng.inner));

        let cert = Arc::new(Certificate::from_pem_multiple(keys::PEM_CERT).unwrap());
        let key = Arc::new(Pk::from_private_key(keys::PEM_KEY, None).unwrap());
        config.push_cert(cert, key).unwrap();

        let rc_config = Arc::new(config);
        let mut ctx = Context::new(rc_config);
        ctx.establish(stream, None).unwrap();
        let mut server_session = BufReader::new(ctx);
        println!("TVM run: a new user is coming ...");
        if let Err(_) = server_session.read(
            exec.get_input("input")
                .unwrap()
                .data()
                .view()
                .as_mut_slice(),
        ) {
            continue;
        }
        let ts1 = timestamp();
        println!("TimeStamp: {}", ts1);
        let sy_time = SystemTime::now();
        exec.run();
        let duration = SystemTime::now()
            .duration_since(sy_time)
            .unwrap()
            .as_micros();
        server_session
            .get_mut()
            .write(exec.get_output(0).unwrap().data().as_slice())
            .unwrap();
        println!(
            "output len: {:?}",
            exec.get_output(0).unwrap().data().as_slice().len()
        );
        println!("{:?}", duration);
        //only try once
        break;
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

use std::process::Command;

macro_rules! mf_dir {
    ($p:literal) => {
        concat!(env!("CARGO_MANIFEST_DIR"), $p)
    };
}

fn main() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let build_output = Command::new("python")
        .arg(mf_dir!("/src/build_model.py"))
        .arg(&out_dir)
        .env(
            "PYTHONPATH",
            concat!(env!("TVM_HOME"), "/python", ":", env!("PYTHONPATH")),
        )
        .output()
        .expect("Failed to build model");
    assert!(
        ["model.o", "graph.json", "params.bin"]
            .iter()
            .all(|f| { std::path::Path::new(&format!("{}/{}", out_dir, f)).exists() }),
        "Could not build tvm lib: \nSTDOUT:\n\n{}\n\nSTDERR\n\n{}",
        String::from_utf8(build_output.stdout).unwrap().trim(),
        String::from_utf8(build_output.stderr).unwrap().trim()
    );

    let sysroot_output = Command::new("rustc")
        .args(&["--print", "sysroot"])
        .output()
        .expect("Failed to get sysroot");
    let sysroot = String::from_utf8(sysroot_output.stdout).unwrap();
    let sysroot = sysroot.trim();
    let mut llvm_tools_path = std::path::PathBuf::from(&sysroot);
    llvm_tools_path.push("lib/rustlib/x86_64-unknown-linux-gnu/bin");

    Command::new("rustup")
        .args(&["component", "add", "llvm-tools-preview"])
        .output()
        .expect("failed to install llvm tools");

    std::process::Command::new(llvm_tools_path.join("llvm-objcopy"))
        .arg("--globalize-symbol=__tvm_module_startup")
        .arg("--remove-section=.ctors")
        .arg(&format!("{}/model.o", out_dir))
        .output()
        .expect("gould not gloablize startup function");

    std::process::Command::new(llvm_tools_path.join("llvm-ar"))
        .arg("rcs")
        .arg(&format!("{}/libmodel.a", out_dir))
        .arg(&format!("{}/model.o", out_dir))
        .output()
        .expect("failed to package model archive");

    println!("cargo:rustc-link-lib=static=model");
    println!("cargo:rustc-link-search=native={}", out_dir);
}

mod sp_vkey;

use crate::sp_vkey::SP_VKEY_PEM;
use byteorder::{NetworkEndian, WriteBytesExt};
use ra_common::tcp::tcp_accept;
use ra_enclave::EnclaveRaContext;
use sgx_crypto::tls_psk::server;
use sgx_crypto::random::Rng;

fn main() {
    let client_addr = "localhost:7777";
    let mut client_stream = tcp_accept(&client_addr).expect("Enclave: Client connection failed");
    eprintln!("Enclave: connected to client.{:#?}", &client_addr);
    let context = EnclaveRaContext::init(SP_VKEY_PEM).unwrap();
    let (_signing_key, master_key) = context.do_attestation(&mut client_stream).unwrap();

    // talk to SP directly from now on
    let sp_addr = "localhost:1235";
    let mut sp_stream = tcp_accept(sp_addr).expect("Enclave: SP connection failed!");

    // establish TLS-PSK with SP; enclave is the server
    let mut psk_callback = server::callback(&master_key);
    let mut rng = Rng::new();
    let config = server::config(&mut rng, &mut psk_callback);
    let mut ctx = server::context(&config).unwrap();

    // begin secure communication
    let mut session = ctx.establish(&mut sp_stream, None).unwrap();
    let msg = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque non placerat risus, et lobortis quam. Mauris velit lorem, elementum id neque a, aliquet tempus turpis. Nam eu congue urna, in semper quam. Ut tristique gravida nunc nec feugiat. Proin tincidunt massa a arcu volutpat, sagittis dignissim velit convallis. Cras ac finibus lorem, nec congue felis. Pellentesque fermentum vitae ipsum sed gravida. Nulla consectetur sit amet erat a pellentesque. Donec non velit sem. Sed eu metus felis. Nullam efficitur consequat ante, ut commodo nisi pharetra consequat. Ut accumsan eget ligula laoreet dictum. Maecenas tristique porta convallis. Suspendisse tempor sodales velit, ac luctus urna varius eu. Ut ultrices urna vestibulum vestibulum euismod. Vivamus eu sapien urna.";
    session
        .write_u32::<NetworkEndian>(msg.len() as u32)
        .unwrap();
    write!(&mut session, "{}", msg).unwrap();
    eprintln!("Enclave: done!");
}
// 2048-bit RSASSA-PKCS1-v1_5 public key in PEM format
pub const SP_VKEY_PEM: &str = "\
-----BEGIN RSA PUBLIC KEY-----\n
MIIBCgKCAQEAvtc94gzwX0KeL1HJVh6XdHPXXA4PYE+ClqWUvxp5ts1/nLQzJVcy\
1SHMGaPUCr+IZJBeWapkFpgnJnw7YzdQ2kA8k6GiN/k8hlQMWXA2nE0LDeOHX8i7\
fc31lWy5nHdAXj7SfC/YV5RC/yhkJ2cYNMB15VPRHGQRukdVmvHUFunxwfkHq5mM\
xWWAWO5Km490NCWP7CqBH6ezGm5jUhzYT/n5y5EaVpqwKVE1uYA//L4dFSE7aDzD\
CDb50B9uqPaEyKHwc2taLiSPvQjDQE3BpKTDOqsVnojd9br1vYW/uemYnnlOJbSr\
L7pYuPODmV02by5r+7hgXFQkTADwFQBCmwIDAQAB\n\
-----END RSA PUBLIC KEY-----\
\0";
use crate::error::AttestationError;
use http::{HeaderMap, HeaderValue};
use regex::Regex;
use serde::Deserialize;
use serde_json::Value;
use sgx_crypto::certificate::X509Cert;

pub const CA_CERT_PEM: &str = "\
-----BEGIN CERTIFICATE-----\n\
MIIFSzCCA7OgAwIBAgIJANEHdl0yo7CUMA0GCSqGSIb3DQEBCwUAMH4xCzAJBgNV\
BAYTAlVTMQswCQYDVQQIDAJDQTEUMBIGA1UEBwwLU2FudGEgQ2xhcmExGjAYBgNV\
BAoMEUludGVsIENvcnBvcmF0aW9uMTAwLgYDVQQDDCdJbnRlbCBTR1ggQXR0ZXN0\
YXRpb24gUmVwb3J0IFNpZ25pbmcgQ0EwIBcNMTYxMTE0MTUzNzMxWhgPMjA0OTEy\
MzEyMzU5NTlaMH4xCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEUMBIGA1UEBwwL\
U2FudGEgQ2xhcmExGjAYBgNVBAoMEUludGVsIENvcnBvcmF0aW9uMTAwLgYDVQQD\
DCdJbnRlbCBTR1ggQXR0ZXN0YXRpb24gUmVwb3J0IFNpZ25pbmcgQ0EwggGiMA0G\
CSqGSIb3DQEBAQUAA4IBjwAwggGKAoIBgQCfPGR+tXc8u1EtJzLA10Feu1Wg+p7e\
LmSRmeaCHbkQ1TF3Nwl3RmpqXkeGzNLd69QUnWovYyVSndEMyYc3sHecGgfinEeh\
rgBJSEdsSJ9FpaFdesjsxqzGRa20PYdnnfWcCTvFoulpbFR4VBuXnnVLVzkUvlXT\
L/TAnd8nIZk0zZkFJ7P5LtePvykkar7LcSQO85wtcQe0R1Raf/sQ6wYKaKmFgCGe\
NpEJUmg4ktal4qgIAxk+QHUxQE42sxViN5mqglB0QJdUot/o9a/V/mMeH8KvOAiQ\
byinkNndn+Bgk5sSV5DFgF0DffVqmVMblt5p3jPtImzBIH0QQrXJq39AT8cRwP5H\
afuVeLHcDsRp6hol4P+ZFIhu8mmbI1u0hH3W/0C2BuYXB5PC+5izFFh/nP0lc2Lf\
6rELO9LZdnOhpL1ExFOq9H/B8tPQ84T3Sgb4nAifDabNt/zu6MmCGo5U8lwEFtGM\
RoOaX4AS+909x00lYnmtwsDVWv9vBiJCXRsCAwEAAaOByTCBxjBgBgNVHR8EWTBX\
MFWgU6BRhk9odHRwOi8vdHJ1c3RlZHNlcnZpY2VzLmludGVsLmNvbS9jb250ZW50\
L0NSTC9TR1gvQXR0ZXN0YXRpb25SZXBvcnRTaWduaW5nQ0EuY3JsMB0GA1UdDgQW\
BBR4Q3t2pn680K9+QjfrNXw7hwFRPDAfBgNVHSMEGDAWgBR4Q3t2pn680K9+Qjfr\
NXw7hwFRPDAOBgNVHQ8BAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADANBgkq\
hkiG9w0BAQsFAAOCAYEAeF8tYMXICvQqeXYQITkV2oLJsp6J4JAqJabHWxYJHGir\
IEqucRiJSSx+HjIJEUVaj8E0QjEud6Y5lNmXlcjqRXaCPOqK0eGRz6hi+ripMtPZ\
sFNaBwLQVV905SDjAzDzNIDnrcnXyB4gcDFCvwDFKKgLRjOB/WAqgscDUoGq5ZVi\
zLUzTqiQPmULAQaB9c6Oti6snEFJiCQ67JLyW/E83/frzCmO5Ru6WjU4tmsmy8Ra\
Ud4APK0wZTGtfPXU7w+IBdG5Ez0kE1qzxGQaL4gINJ1zMyleDnbuS8UicjJijvqA\
152Sq049ESDz+1rRGc2NVEqh1KaGXmtXvqxXcTB+Ljy5Bw2ke0v8iGngFBPqCTVB\
3op5KBG3RjbF6RRSzwzuWfL7QErNC8WEy5yDVARzTA5+xmBc388v9Dm21HGfcC8O\
DD+gT9sSpssq0ascmvH49MOgjt1yoysLtdCtJW/9FZpoOypaHx0R+mJTLwPXVMrv\
DaVzWh5aiEx+idkSGMnX\n\
-----END CERTIFICATE-----\
\0";

#[derive(Deserialize, Debug)]
pub struct AttestationResponse {
    // header
    pub advisory_url: Option<String>,
    pub advisory_ids: Option<String>,
    pub request_id: String,
    // body
    pub id: String,
    pub timestamp: String,
    pub version: u16,
    pub isv_enclave_quote_status: String,
    pub isv_enclave_quote_body: String,
    pub revocation_reason: Option<String>,
    pub pse_manifest_status: Option<String>,
    pub pse_manifest_hash: Option<String>,
    pub platform_info_blob: Option<String>,
    pub nonce: Option<String>,
    pub epid_pseudonym: Option<String>,
}

impl AttestationResponse {
    pub fn from_response(
        headers: &HeaderMap,
        body: Vec<u8>,
    ) -> Result<Self, AttestationError> {
        let root_ca_cert = X509Cert::new_from_pem(CA_CERT_PEM.as_bytes()).unwrap();
        Self::verify_response(&root_ca_cert, &headers, &body[..])?;

        let body: Value = {
            let body = String::from_utf8(body).unwrap();
            serde_json::from_str(&body).unwrap()
        };
        // if cfg!(feature = "verbose") {
        //     eprintln!("==============headers Result==============");
        //     eprintln!("{:#?}", headers);
        //     eprintln!("==============================================");
        //     eprintln!("==============body Result==============");
        //     eprintln!("{:#?}", body);
        //     eprintln!("==============================================");
        // }
        let h = |x: &HeaderValue| x.to_str().unwrap().to_owned();
        let b = |x: &str| x.to_owned();
        Ok(Self {
            // header
            advisory_ids: headers.get("advisory-ids").map(h),
            advisory_url: headers.get("advisory-url").map(h),
            request_id: headers.get("request-id").map(h).unwrap(),
            // body
            id: body["id"].as_str().unwrap().to_owned(),
            timestamp: body["timestamp"].as_str().unwrap().to_owned(),
            version: body["version"].as_u64().unwrap() as u16,
            isv_enclave_quote_status: body["isvEnclaveQuoteStatus"].as_str().unwrap().to_owned(),
            isv_enclave_quote_body: body["isvEnclaveQuoteBody"].as_str().unwrap().to_owned(),
            revocation_reason: body["revocationReason"].as_str().map(b),
            pse_manifest_status: body["pseManifestStatus"].as_str().map(b),
            pse_manifest_hash: body["pseManifestHash"].as_str().map(b),
            platform_info_blob: body["platformInfoBlob"].as_str().map(b),
            nonce: body["nonce"].as_str().map(b),
            epid_pseudonym: body["epidPseudonym"].as_str().map(b),
        })
    }

    fn verify_response(
        root_ca_cert: &X509Cert,
        headers: &HeaderMap,
        body: &[u8],
    ) -> Result<(), AttestationError> {
        // Split certificates
        let re = Regex::new(
            "(-----BEGIN .*-----\\n)\
                            ((([A-Za-z0-9+/]{4})*\
                              ([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)*\\n)+)\
                            (-----END .*-----)",
        )
        .unwrap();
        let (mut certificate, mut ca_certificate) = {
            let c = headers
                .get("x-iasreport-signing-certificate")
                .unwrap()
                .to_str()
                .unwrap();
            let c = percent_encoding::percent_decode_str(c)
                .decode_utf8()
                .unwrap();
            let c = re
                .find_iter(&c)
                .map(|m| m.as_str().to_owned())
                .collect::<Vec<String>>();
            let mut c_iter = c.into_iter();
            let mut certificate = c_iter.next().unwrap();
            certificate.push('\0');
            let certificate = X509Cert::new_from_pem(certificate.as_bytes()).unwrap();
            let mut ca_certificate = c_iter.next().unwrap();
            ca_certificate.push('\0');
            let ca_certificate = X509Cert::new_from_pem(ca_certificate.as_bytes()).unwrap();
            (certificate, ca_certificate)
        };

        // Check if the root certificate is the same as the SP-provided certificate
        if root_ca_cert != &ca_certificate {
            return Err(AttestationError::MismatchedIASRootCertificate);
        }

        // Check if the certificate is signed by root CA
        certificate
            .verify_this_certificate(&mut ca_certificate)
            .map_err(|_| AttestationError::InvalidIASCertificate)?;

        // Check if the signature is correct
        let signature = base64::decode(
            headers
                .get("x-iasreport-signature")
                .unwrap()
                .to_str()
                .unwrap(),
        )
        .unwrap();
        certificate
            .verify_signature(body, &signature[..])
            .map_err(|_| AttestationError::BadSignature)?;
        Ok(())
    }
}
use crate::error::EnclaveRaError;
use crate::context::EnclaveRaContext;
use sgx_crypto::random::Rng;
use sgx_crypto::tls_psk::server;
use sgx_crypto::signature::SigningKey;
use ra_common::tcp::tcp_accept;
use std::net::{TcpStream};
use std::collections::HashMap;
use std::io::{BufReader, Read, Write};
use serde::{Deserialize, Serialize};
use http::{HeaderMap, StatusCode};
use std::sync::Arc;
use mbedtls::ssl::Context;

pub const SP_VKEY_PEM: &str = "\
-----BEGIN RSA PUBLIC KEY-----\n
MIIBCgKCAQEAvtc94gzwX0KeL1HJVh6XdHPXXA4PYE+ClqWUvxp5ts1/nLQzJVcy\
1SHMGaPUCr+IZJBeWapkFpgnJnw7YzdQ2kA8k6GiN/k8hlQMWXA2nE0LDeOHX8i7\
fc31lWy5nHdAXj7SfC/YV5RC/yhkJ2cYNMB15VPRHGQRukdVmvHUFunxwfkHq5mM\
xWWAWO5Km490NCWP7CqBH6ezGm5jUhzYT/n5y5EaVpqwKVE1uYA//L4dFSE7aDzD\
CDb50B9uqPaEyKHwc2taLiSPvQjDQE3BpKTDOqsVnojd9br1vYW/uemYnnlOJbSr\
L7pYuPODmV02by5r+7hgXFQkTADwFQBCmwIDAQAB\n\
-----END RSA PUBLIC KEY-----\
\0";

#[derive(Serialize, Deserialize, Debug)]
pub struct HttpRespWrap{
    #[serde(with = "http_serde::header_map")] 
    pub map: HeaderMap,
    #[serde(with = "http_serde::status_code")] 
    pub statu: StatusCode,
}

pub fn attestation(client:&str, sp:&str, keep_message:fn(BufReader<Context>))->Result<EnclaveRaContext, EnclaveRaError>{
    let mut client_stream = tcp_accept(client).expect("Enclave: Client connection failed");
    eprintln!("Enclave: listening at:{:?}", client);
    let mut encontext = EnclaveRaContext::init(SP_VKEY_PEM).unwrap();
    let (_signing_key, master_key) = encontext.do_attestation(&mut client_stream).unwrap();

    // talk to SP directly from now on
    //let sp_port = 1235;
    let sp_stream = tcp_accept(sp).expect("Enclave: SP connection failed");
    // establish TLS-PSK with SP; enclave is the server
    let mut psk_callback = server::callback(&master_key);
    let rng = Rng::new();
    let config = server::config(rng, &mut psk_callback);
    let mut ctx = server::context(Arc::new(config));
    // begin secure communication
    ctx.establish(sp_stream, None).unwrap();
    eprintln!("Enclave: done!");
    let server_session = BufReader::new(ctx);
    keep_message(server_session);
    Ok(encontext)
}
pub fn attestation_get_report(client:&str, sp:&str, keep_message:fn(TcpStream, &mut HashMap<u8, (Vec<u8>, Vec<u8>)>), report: &mut HashMap<u8, (Vec<u8>, Vec<u8>)> )->Result<SigningKey, EnclaveRaError>{
    let mut client_stream = tcp_accept(client).expect("Enclave: Client connection failed");
    eprintln!("Enclave: connected to client.");
    let mut encontext = EnclaveRaContext::init(SP_VKEY_PEM).unwrap();
    let (_signing_key, _master_key) = encontext.do_attestation(&mut client_stream).unwrap();

    // talk to SP directly from now on
    //let sp_port = 1235;
    println!("wait for connect:");
    let sp_stream = tcp_accept(sp).expect("Enclave: SP connection failed");
    println!("wait for connect: done!");
    keep_message(sp_stream, report);
    Ok(encontext.signer_key)
}use crate::error::EnclaveRaError;
use crate::local_attestation;
use crate::EnclaveRaResult;
use ra_common::derive_secret_keys;
use ra_common::msg::{Quote, RaMsg2, RaMsg3, RaMsg4};
use sgx_crypto::cmac::{Cmac, MacTag};
use sgx_crypto::digest::sha256;
use sgx_crypto::key_exchange::OneWayAuthenticatedDHKE;
use sgx_crypto::random::Rng;
use sgx_crypto::signature::{VerificationKey, SigningKey};
use sgx_isa::{Report, Targetinfo};
use std::io::{Read, Write};
use std::mem::size_of;
use std::time::SystemTime;

pub struct EnclaveRaContext {
    pub key_exchange: Option<OneWayAuthenticatedDHKE>,
    pub sp_vkey: VerificationKey,
    pub signer_key: SigningKey,
    pub quote: Quote
}

impl EnclaveRaContext {
    pub fn init(sp_vkey_pem: &str) -> EnclaveRaResult<Self> {
        let mut rng = Rng::new();
        let mut signer_rng = Rng::new();
        let key_exchange = OneWayAuthenticatedDHKE::generate_keypair(&mut rng)?;
        let signer_key = SigningKey::generate_keypair(&mut signer_rng).expect("generate signing key pair failed!");
        Ok(Self {
            sp_vkey: VerificationKey::new(sp_vkey_pem.as_bytes())?,
            key_exchange: Some(key_exchange),
            signer_key,
            quote: [0u8;size_of::<Quote>()]
        })
    }

    pub fn do_attestation(
        &mut self,
        mut client_stream: &mut (impl Read + Write),
    ) -> EnclaveRaResult<(MacTag, MacTag)> {
        let (sk, mk) = self.process_msg_2(client_stream).unwrap();
        let msg4: RaMsg4 = bincode::deserialize_from(&mut client_stream).unwrap();
        if !msg4.is_enclave_trusted {
            return Err(EnclaveRaError::EnclaveNotTrusted);
        }
        match msg4.is_pse_manifest_trusted {
            Some(t) => {
                if !t {
                    return Err(EnclaveRaError::PseNotTrusted);
                }
            }
            None => {}
        }
        Ok((sk, mk))
    }

    // Return (signing key, master key)
    pub fn process_msg_2(
        &mut self,
        mut client_stream: &mut (impl Read + Write),
    ) -> EnclaveRaResult<(MacTag, MacTag)> {

        //generate the msg_1, send to sp enclave
        let g_a = self.key_exchange.as_ref().unwrap().get_public_key()?;
        bincode::serialize_into(&mut client_stream, &g_a).unwrap();

        let msg2: RaMsg2 = bincode::deserialize_from(&mut client_stream).unwrap();

        // Verify and derive KDK and then other secret keys
        let mut rng = Rng::new();
        let kdk = self
            .key_exchange
            .take()
            .unwrap()
            .verify_and_derive(&msg2.g_b, &msg2.sign_gb_ga, &mut self.sp_vkey, &mut rng)
            .unwrap();
        let mut kdk_cmac = Cmac::new(&kdk)?;
        let (smk, sk, mk, vk) = derive_secret_keys(&mut kdk_cmac)?;
        let mut smk = Cmac::new(&smk)?;

        // Verify MAC tag of MSG2
        msg2.verify_mac(&mut smk)?;

        // Obtain SHA-256(g_a || g_b || vk)
        let mut verification_msg = Vec::new();
        verification_msg.write_all(g_a.as_ref()).unwrap();
        verification_msg.write_all(&msg2.g_b).unwrap();
        verification_msg.write_all(&vk).unwrap();
        let verification_digest = sha256(&verification_msg[..])?;
        //add a ecdsa public key to report data for a sign
        let sy_time = SystemTime::now();
        let signer_public_key = self.signer_key.get_public_key()?;
        println!("public_key generation time: {:?}", SystemTime::now().duration_since(sy_time).unwrap().as_micros());
        let mut _report_data = [0u8; 64];
        (&mut _report_data[..(verification_digest.len())]).clone_from_slice(&verification_digest);
        
        //signer_public_key.len() ==33, so we need to copy to _report_data at (verification_digest.len()-1)
        (&mut _report_data[(verification_digest.len()-1)..]).clone_from_slice(&signer_public_key);
        // Obtain Quote
        let sy_time = SystemTime::now();
        self.get_quote(&_report_data[..], client_stream)?;
        println!("quote generation time: {:?}", SystemTime::now().duration_since(sy_time).unwrap().as_micros());
        // Send MAC for msg3 to client
        let msg3 = RaMsg3::new(&mut smk, g_a, None, self.quote)?;
        client_stream.write_all(&msg3.mac).unwrap();

        Ok((sk, mk))
    }

    /// Get quote from Quote Enclave. The length of report_data must be <= 64 bytes.
    pub fn get_quote(
        &mut self,
        report_data: &[u8],
        client_stream: &mut (impl Read + Write),
    ) -> EnclaveRaResult<Quote> {
        if report_data.len() > 64 {
            return Err(EnclaveRaError::ReportDataLongerThan64Bytes);
        }

        // Obtain QE's target info to build a report for local attestation.
        // Then, send the report back to client.
        let mut _report_data = [0u8; 64];
        (&mut _report_data[..(report_data.len())]).copy_from_slice(report_data);
        let mut target_info = [0u8; Targetinfo::UNPADDED_SIZE];
        client_stream.read_exact(&mut target_info).unwrap();
        let target_info = Targetinfo::try_copy_from(&target_info).unwrap();
        let report = Report::for_target(&target_info, &_report_data);


        //add some custom data to report, then get the quote
        client_stream.write_all(report.as_ref()).unwrap();

        // Obtain quote and QE report from client
        // let mut quote = [0u8; size_of::<Quote>()];
        client_stream.read_exact(&mut self.quote[..]).unwrap();
        let qe_report_len = 432usize;
        let mut qe_report = vec![0u8; qe_report_len];
        client_stream.read_exact(&mut qe_report[..]).unwrap();

        // Verify that the report is generated by QE
        local_attestation::verify_local_attest(&qe_report[..])
            .map_err(|e| EnclaveRaError::LocalAttestation(e))?;
        Ok(self.quote)
    }
}
pub mod context;
pub mod error;
pub mod local_attestation;
pub mod tls_enclave;
// pub mod attestation_response;

pub use crate::context::*;
pub use crate::error::*;
pub use crate::tls_enclave::*;
// pub use crate::attestation_response::*;

pub type EnclaveRaResult<T> = Result<T, EnclaveRaError>;
#[derive(Debug)]
pub enum EnclaveRaError {
    Crypto(sgx_crypto::error::CryptoError),
    IntegrityError,
    ReportDataLongerThan64Bytes,
    LocalAttestation(LocalAttestationError),
    EnclaveNotTrusted,
    PseNotTrusted,
}

impl std::convert::From<sgx_crypto::error::CryptoError> for EnclaveRaError {
    fn from(e: sgx_crypto::error::CryptoError) -> Self {
        Self::Crypto(e)
    }
}

#[derive(Debug)]
pub enum LocalAttestationError {
    Crypto(sgx_crypto::error::CryptoError),
    IncorrectReportLength,
    IntegrityError,
}

impl std::convert::From<sgx_crypto::error::CryptoError> for LocalAttestationError {
    fn from(e: sgx_crypto::error::CryptoError) -> Self {
        Self::Crypto(e)
    }
}

#[derive(Debug)]
pub enum AttestationError {
    MismatchedIASRootCertificate,
    InvalidIASCertificate,
    BadSignature,
}// Modified from https://gist.github.com/Vinc0682/10c074202c995e4f87b4edf278ec4cae
use crate::error::LocalAttestationError;
use sgx_crypto::cmac::Cmac;
use sgx_isa::{Keyname, Keyrequest, Report, Targetinfo};

/// Fetches the own target info and puts it into a byte-vector.
pub fn get_own_targetinfo() -> Vec<u8> {
    let ti = Targetinfo::from(Report::for_self());
    let result: &[u8] = ti.as_ref();
    result.to_vec().clone()
}

/// Tries to create a report for the given target and puts it into a byte-vector.
/// Returns None if the target is invalid, returns the report otherwise.
pub fn locally_attest(target: &Vec<u8>, data: &[u8; 64]) -> Option<Vec<u8>> {
    let ti = Targetinfo::try_copy_from(&target[..])?;
    let report = Report::for_target(&ti, data);
    let report: &[u8] = report.as_ref();
    Some(report.to_vec().clone())
}

/// Verifies a report created by locally_attest (or any other report generated by an enclave).
/// Returns true if the report is correctly formed and has been generated on the same machine/CPU
/// as the current enclave.
pub fn verify_local_attest(report: &[u8]) -> Result<(), LocalAttestationError> {
    if report.len() != Report::UNPADDED_SIZE {
        return Err(LocalAttestationError::IncorrectReportLength);
    }
    // Can unwrap since the length is verified
    let report = Report::try_copy_from(report).unwrap();
    verify_report(&report)
}

/// Verifies the given report locally, a.k.a. returns true if the Report was created in an enclave
/// on the same CPU.
pub fn verify_report(report: &Report) -> Result<(), LocalAttestationError> {
    // Derive the report key.
    let request = Keyrequest {
        keyname: Keyname::Report as _,
        keyid: report.keyid.clone(),
        ..Default::default()
    };
    // Maybe result false instead of panicking, but the specs
    // ( https://software.intel.com/en-us/articles/intel-sdm Volume 3C, Chapter 40-4 )
    // state that EGETKEY should have a problem with this parameters, so if it doesn't work
    // there might be a deeper issue making a panic appropriate.
    let key = request.egetkey().expect("Can't derive report key");

    // Extract the data that is signed.
    let report_data: &[u8] = report.as_ref();
    let mut mac_data = &report_data[0..Report::UNPADDED_SIZE - 48];

    // Compute and verify the mac on the data.
    let mut mac = Cmac::new(&key)?;
    mac.verify(&mut mac_data, &report.mac)
        .map_err(|_| LocalAttestationError::IntegrityError)
}
use byteorder::{NetworkEndian, ReadBytesExt, WriteBytesExt};
use hyper::Response;
use ra_common::tcp::tcp_connect;
use ra_sp::{AttestationResult, HttpRespWrap, SpConfigs, SpRaContext};
use sgx_crypto::random::Rng;
use sgx_crypto::tls_psk::client;
use std::collections::HashMap;
use std::io::{BufReader, Read, Write};
use std::mem;
use std::net::{TcpListener};
use std::sync::Arc;
use std::time::Duration;

const SCHEDULE_ID: u8 = 255;
const STOP_LABEL: u8 = 250;
fn parse_config_file(path: &str) -> SpConfigs {
    serde_json::from_reader(std::fs::File::open(path).unwrap()).unwrap()
}

fn main() {
    let configs = parse_config_file("examples/data/settings.json");
    let listener_address = configs.listener_address.clone();
    let mut http_report = HashMap::new();
    let listener = TcpListener::bind(listener_address).unwrap();
    //listener.set_nonblocking(true).expect("Cannot set non-blocking");
    eprintln!("SP: listening at {:?}.", configs.listener_address.clone());
    for stream in listener.incoming() {
        eprintln!("SP: new socket incoming.");
        match stream {
            Err(e) => {
                eprintln!("failed: {}", e);
                continue;
            }
            Ok(mut stream) => {
                let enclave_id = stream.read_u8().unwrap();
                let client_ip = stream.peer_addr().unwrap().ip();
                let spconfig = match configs.generate_spconfig(enclave_id, &client_ip) {
                    Err(e) => {
                        eprintln!("client err, ip:{}", stream.peer_addr().unwrap());
                        eprintln!("the client socket is not configed in settings.json: {}", e);
                        continue;
                    }
                    Ok(config) => config,
                };
                let enclave_port = spconfig.enclave_port.clone();
                let mut context = SpRaContext::init(spconfig).unwrap();
                let result = match context.do_attestation(&mut stream) {
                    Ok(result) => {
                        let http_resp =
                            mem::replace(&mut context.get_ias_client().http_resp, None).unwrap();
                        http_report.insert(context.get_spconfig().enclave_id, http_resp);
                        println!("enclave_id: {}", context.get_spconfig().enclave_id);
                        result
                    }
                    Err(e) => {
                        println!("Do remote attestation failed, the reason is: {}", e);
                        continue;
                    }
                };
                if context.get_spconfig().enclave_id == SCHEDULE_ID {
                    send_http_report_to_schedule(&mut http_report, enclave_port);
                    continue;
                } else {
                    // establish TLS-PSK with enclave; SP is the client
                    do_tls_psk(result, enclave_port, keep_message);
                }
            }
        }
    }
}
// establish TLS-PSK with enclave; SP is the client
pub fn do_tls_psk(
    result: AttestationResult,
    enclave_port: String,
    keep_message: fn(BufReader<mbedtls::ssl::Context>),
) {
    let timeout = Duration::from_secs(5);
    let enclave_stream =
        tcp_connect(&enclave_port, timeout).expect("SP: Enclave connection failed");
    let rng = Rng::new();
    let config = client::config(rng, &result.master_key).unwrap();
    let rc_config = Arc::new(config);
    let mut ctx = client::context(rc_config);

    // begin secure communication
    ctx.establish(enclave_stream, None).unwrap();
    let session = BufReader::new(ctx);
    keep_message(session);
}
//enable enclave can communite with sp for more message
pub fn keep_message(session: BufReader<mbedtls::ssl::Context>) {
    let mut sess = session;
    let len = sess.read_u32::<NetworkEndian>().unwrap() as usize;
    let mut msg = vec![0u8; len];
    sess.read_exact(&mut msg[..]).unwrap();
    let msg = std::str::from_utf8(msg.as_slice()).unwrap();
    let msg_ref = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque non placerat risus, et lobortis quam. Mauris velit lorem, elementum id neque a, aliquet tempus turpis. Nam eu congue urna, in semper quam. Ut tristique gravida nunc nec feugiat. Proin tincidunt massa a arcu volutpat, sagittis dignissim velit convallis. Cras ac finibus lorem, nec congue felis. Pellentesque fermentum vitae ipsum sed gravida. Nulla consectetur sit amet erat a pellentesque. Donec non velit sem. Sed eu metus felis. Nullam efficitur consequat ante, ut commodo nisi pharetra consequat. Ut accumsan eget ligula laoreet dictum. Maecenas tristique porta convallis. Suspendisse tempor sodales velit, ac luctus urna varius eu. Ut ultrices urna vestibulum vestibulum euismod. Vivamus eu sapien urna.";
    assert_eq!(msg, msg_ref);
    eprintln!("SP: message from Enclave = \"{}\"", msg);
    eprintln!("SP: done!");
}
//send all of the report getting from IAS to schedule for check
pub fn send_http_report_to_schedule(
    http_report: &mut HashMap<u8, Response<Vec<u8>>>,
    enclave_port: String,
) {
    let timeout = Duration::from_secs(50);
    println!("{}", enclave_port);
    let mut enclave_stream =
        tcp_connect(&enclave_port, timeout).expect("SP: Enclave connection failed");
    for (k, v) in http_report {
        enclave_stream.write_u8(*k).unwrap();
        let wrapped = HttpRespWrap {
            map: v.headers().clone(),
            statu: v.status(),
        };
        let header = serde_json::to_vec(&wrapped).unwrap();
        let len = header.len() as u32;
        enclave_stream.write_u32::<NetworkEndian>(len).unwrap();
        enclave_stream.write_all(&header).unwrap();
        let body = v.body_mut();
        let len = body.len() as u32;
        enclave_stream.write_u32::<NetworkEndian>(len).unwrap();
        enclave_stream.write_all(&body).unwrap();
    }
    enclave_stream.write_u8(STOP_LABEL).unwrap();
}
extern crate clap;
use ra_sp::{context::verify_quote, SpConfigs};
// use byteorder::{NetworkEndian, WriteBytesExt}; 
use ra_common::tcp::tcp_connect;
use std::time::Duration;
use std::io::Write;
use clap::App;

fn parse_config_file(path: &str) -> SpConfigs {
    serde_json::from_reader(std::fs::File::open(path).unwrap()).unwrap()
}

fn main() {
    let matches = App::new("tvm-user")
        .version("1.0")
        .author("simplelin. ")
        .about("Do remote attestation")
        .args_from_usage(
            "-e   --enclave=[String] 'Sets IP and Port for sgx task enclave,such as: \"127.0.0.1:7777\"'
            -n   --number=[u8]     'Serial number for the enclave that will send quote to client,\"0-255\".such as:0' ")
        .get_matches();
    let enclave  = matches.value_of("enclave").unwrap_or("127.0.0.1:7777");
    let number  = matches.value_of("number").unwrap_or("0");//.as_bytes();
    let number  = number.parse::<u8>().expect("the input value is invalid,that should be a id and type is \"u8\"");
    let timeout = Duration::from_secs(5);
    let mut enclave_stream =
        tcp_connect(enclave, timeout).expect("Client: Enclave connection failed");
    eprintln!("Client: connected to enclave {:?}.", enclave);
    
    eprintln!("Starting verify_quote .");
    let configs = parse_config_file("examples/data/settings.json");
    verify_quote(configs, &mut enclave_stream).unwrap();
    let rand_sig = [2u8; 4];
    enclave_stream.write_all(&rand_sig).unwrap();

}use crate::error::AttestationError;
use hyper::header::{HeaderMap, HeaderValue};
use regex::Regex;
use serde::Deserialize;
use serde_json::Value;
use sgx_crypto::certificate::X509Cert;

#[derive(Deserialize, Debug)]
pub struct AttestationResponse {
    // header
    pub advisory_url: Option<String>,
    pub advisory_ids: Option<String>,
    pub request_id: String,
    // body
    pub id: String,
    pub timestamp: String,
    pub version: u16,
    pub isv_enclave_quote_status: String,
    pub isv_enclave_quote_body: String,
    pub revocation_reason: Option<String>,
    pub pse_manifest_status: Option<String>,
    pub pse_manifest_hash: Option<String>,
    pub platform_info_blob: Option<String>,
    pub nonce: Option<String>,
    pub epid_pseudonym: Option<String>,
}

impl AttestationResponse {
    pub fn from_response(
        root_ca_cert: &X509Cert,
        headers: &HeaderMap,
        body: Vec<u8>,
    ) -> Result<Self, AttestationError> {
        Self::verify_response(root_ca_cert, &headers, &body[..])?;

        let body: Value = {
            let body = String::from_utf8(body).unwrap();
            serde_json::from_str(&body).unwrap()
        };
        if cfg!(feature = "verbose") {
            eprintln!("==============headers Result==============");
            eprintln!("{:#?}", headers);
            eprintln!("==============================================");
            eprintln!("==============body Result==============");
            eprintln!("{:#?}", body);
            eprintln!("==============================================");
        }
        let h = |x: &HeaderValue| x.to_str().unwrap().to_owned();
        let b = |x: &str| x.to_owned();
        Ok(Self {
            // header
            advisory_ids: headers.get("advisory-ids").map(h),
            advisory_url: headers.get("advisory-url").map(h),
            request_id: headers.get("request-id").map(h).unwrap(),
            // body
            id: body["id"].as_str().unwrap().to_owned(),
            timestamp: body["timestamp"].as_str().unwrap().to_owned(),
            version: body["version"].as_u64().unwrap() as u16,
            isv_enclave_quote_status: body["isvEnclaveQuoteStatus"].as_str().unwrap().to_owned(),
            isv_enclave_quote_body: body["isvEnclaveQuoteBody"].as_str().unwrap().to_owned(),
            revocation_reason: body["revocationReason"].as_str().map(b),
            pse_manifest_status: body["pseManifestStatus"].as_str().map(b),
            pse_manifest_hash: body["pseManifestHash"].as_str().map(b),
            platform_info_blob: body["platformInfoBlob"].as_str().map(b),
            nonce: body["nonce"].as_str().map(b),
            epid_pseudonym: body["epidPseudonym"].as_str().map(b),
        })
    }

    fn verify_response(
        root_ca_cert: &X509Cert,
        headers: &HeaderMap,
        body: &[u8],
    ) -> Result<(), AttestationError> {
        // Split certificates
        let re = Regex::new(
            "(-----BEGIN .*-----\\n)\
                            ((([A-Za-z0-9+/]{4})*\
                              ([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)*\\n)+)\
                            (-----END .*-----)",
        )
        .unwrap();
        let (mut certificate, mut ca_certificate) = {
            let c = headers
                .get("x-iasreport-signing-certificate")
                .unwrap()
                .to_str()
                .unwrap();
            let c = percent_encoding::percent_decode_str(c)
                .decode_utf8()
                .unwrap();
            let c = re
                .find_iter(&c)
                .map(|m| m.as_str().to_owned())
                .collect::<Vec<String>>();
            let mut c_iter = c.into_iter();
            let mut certificate = c_iter.next().unwrap();
            certificate.push('\0');
            let certificate = X509Cert::new_from_pem(certificate.as_bytes()).unwrap();
            let mut ca_certificate = c_iter.next().unwrap();
            ca_certificate.push('\0');
            let ca_certificate = X509Cert::new_from_pem(ca_certificate.as_bytes()).unwrap();
            (certificate, ca_certificate)
        };

        // Check if the root certificate is the same as the SP-provided certificate
        if root_ca_cert != &ca_certificate {
            return Err(AttestationError::MismatchedIASRootCertificate);
        }

        // Check if the certificate is signed by root CA
        certificate
            .verify_this_certificate(&mut ca_certificate)
            .map_err(|_| AttestationError::InvalidIASCertificate)?;

        // Check if the signature is correct
        let signature = base64::decode(
            headers
                .get("x-iasreport-signature")
                .unwrap()
                .to_str()
                .unwrap(),
        )
        .unwrap();
        certificate
            .verify_signature(body, &signature[..])
            .map_err(|_| AttestationError::BadSignature)?;
        Ok(())
    }
}
use crate::config::{SpConfig, SpConfigs};
use crate::error::SpRaError;
use crate::ias::IasClient;
use crate::{AttestationResult, SpRaResult};
use byteorder::{LittleEndian, ReadBytesExt};
use mbedtls::rng::Random;
use ra_common::derive_secret_keys;
use ra_common::msg::{Quote, RaMsg0, RaMsg1, RaMsg2, RaMsg3, RaMsg4, Spid};
use sgx_crypto::certificate::X509Cert;
use sgx_crypto::cmac::{Cmac, MacTag};
use sgx_crypto::digest::{sha256, Sha256Digest};
use sgx_crypto::key_exchange::{DHKEPublicKey, OneWayAuthenticatedDHKE};
use sgx_crypto::signature::{SigningKey, VerificationKey};
use byteorder::{NetworkEndian, WriteBytesExt};
use sgx_crypto::random::Rng;
use sgxs::sigstruct;
use std::convert::TryInto;
use std::fs::File;
use std::io::{Read, Write};
use std::path::Path;
use std::time::SystemTime;
use std::mem::size_of;
// use aesm_client::unix::AesmClientExt;

pub struct SpRaContext {
    config: SpConfig,
    sigstruct: sigstruct::Sigstruct,
    ias_client: IasClient,
    sp_private_key: SigningKey,
    rng: Rng,
    key_exchange: Option<OneWayAuthenticatedDHKE>,
    g_a: Option<DHKEPublicKey>,
    verification_digest: Option<Sha256Digest>,
    smk: Option<Cmac>,
    sk_mk: Option<(MacTag, MacTag)>,
}

impl SpRaContext {
    pub fn init(mut config: SpConfig) -> SpRaResult<Self> {
        assert!(config.linkable, "Only Linkable Quote supported");
        assert!(!config.random_nonce, "Random nonces not supported");
        assert!(
            !config.use_platform_service,
            "Platform service not supported"
        );
        if cfg!(feature = "verbose") {
            eprintln!("==================SP Config==================");
            eprintln!("{:#?}", config);
            eprintln!("=============================================");
        }

        // Preparing for binary search
        config.quote_trust_options.sort();
        config.pse_trust_options.as_mut().map(|v| v.sort());

        let cert = X509Cert::new_from_pem_file(Path::new(&config.ias_root_cert_pem_path))?;

        let mut rng = Rng::new();
        let key_exchange = OneWayAuthenticatedDHKE::generate_keypair(&mut rng)?;
        let sp_private_key =
            SigningKey::new_from_file(Path::new(&config.sp_private_key_pem_path), None)?;
        let mut sigstruct = File::open(Path::new(&config.sigstruct_path))?;
        let sigstruct = sigstruct::read(&mut sigstruct)?;

        Ok(Self {
            config,
            sigstruct,
            ias_client: IasClient::new(cert),
            sp_private_key,
            rng,
            key_exchange: Some(key_exchange),
            g_a: None,
            verification_digest: None,
            smk: None,
            sk_mk: None,
        })
    }
    //get a shared reference of SpConfig
    pub fn get_spconfig(&self) -> &SpConfig {
        &self.config
    }
    //get a shared reference of IasClient
    pub fn get_ias_client(&mut self) -> &mut IasClient {
        &mut self.ias_client
    }
    #[tokio::main]
    pub async fn do_attestation(
        &mut self,
        mut client_stream: &mut (impl Read + Write),
    ) -> SpRaResult<AttestationResult> {
        // Not using MSG0 for now.
        let _msg0: RaMsg0 = bincode::deserialize_from(&mut client_stream)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG0 received ");
        }
        let sy_time = SystemTime::now();
        let msg1: RaMsg1 = bincode::deserialize_from(&mut client_stream)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG1 received");
        }
        println!(
            "{:?}",
            SystemTime::now()
                .duration_since(sy_time)
                .unwrap()
                .as_micros()
        );
        let sy_time = SystemTime::now();
        let msg2 = self.process_msg_1(msg1).await?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG1 processed");
        }
        bincode::serialize_into(&mut client_stream, &msg2)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG2 sent");
        }
        println!(
            "{:?}",
            SystemTime::now()
                .duration_since(sy_time)
                .unwrap()
                .as_micros()
        );
        let sy_time = SystemTime::now();
        let msg3: RaMsg3 = bincode::deserialize_from(&mut client_stream)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG3 received");
        }
        println!(
            "{:?}",
            SystemTime::now()
                .duration_since(sy_time)
                .unwrap()
                .as_micros()
        );
        let sy_time = SystemTime::now();
        let (msg4, epid_pseudonym) = self.process_msg_3(msg3).await?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG4 generated");
        }
        println!(
            "{:?}",
            SystemTime::now()
                .duration_since(sy_time)
                .unwrap()
                .as_micros()
        );
        let sy_time = SystemTime::now();
        bincode::serialize_into(&mut client_stream, &msg4)?;
        if cfg!(feature = "verbose") {
            eprintln!("MSG4 sent");
        }

        if !msg4.is_enclave_trusted {
            return Err(SpRaError::EnclaveNotTrusted);
        }
        match msg4.is_pse_manifest_trusted {
            Some(t) => {
                if !t {
                    return Err(SpRaError::EnclaveNotTrusted);
                }
            }
            None => {}
        }

        let (signing_key, master_key) = self.sk_mk.take().unwrap();
        println!(
            "decode {:?}",
            SystemTime::now()
                .duration_since(sy_time)
                .unwrap()
                .as_micros()
        );
        Ok(AttestationResult {
            epid_pseudonym,
            signing_key,
            master_key,
        })
    }

    pub async fn process_msg_1(&mut self, msg1: RaMsg1) -> SpRaResult<RaMsg2> {
        // Get sigRL
        let sig_rl = self
            .ias_client
            .get_sig_rl(&msg1.gid, &self.config.primary_subscription_key);

        let key_exchange = self.key_exchange.take().unwrap();
        let g_b = key_exchange.get_public_key()?;

        // Sign and derive KDK and other secret keys
        let (kdk, sign_gb_ga) =
            key_exchange.sign_and_derive(&msg1.g_a, &mut self.sp_private_key, &mut self.rng)?;
        let mut kdk_cmac = Cmac::new(&kdk)?;
        let (smk, sk, mk, vk) = derive_secret_keys(&mut kdk_cmac)?;
        let smk = Cmac::new(&smk)?;

        // Obtain SHA-256(g_a || g_b || vk)
        let mut verification_msg = Vec::new();
        verification_msg.write_all(&msg1.g_a).unwrap();
        verification_msg.write_all(&g_b[..]).unwrap();
        verification_msg.write_all(&vk).unwrap();
        let verification_digest = sha256(&verification_msg[..])?;

        // Set context
        self.smk = Some(smk);
        self.sk_mk = Some((sk, mk));
        self.verification_digest = Some(verification_digest);
        self.g_a = Some(msg1.g_a.clone());

        let spid: Spid = hex::decode(&self.config.spid)
            .unwrap()
            .as_slice()
            .try_into()
            .unwrap();
        let quote_type = self.config.linkable as u16;

        Ok(RaMsg2::new(
            self.smk.as_mut().unwrap(),
            g_b,
            spid,
            quote_type,
            sign_gb_ga,
            sig_rl.await?,
        )?)
    }

    pub async fn process_msg_3(&mut self, msg3: RaMsg3) -> SpRaResult<(RaMsg4, Option<String>)> {
        // Integrity check
        if &msg3.g_a[..] != &self.g_a.as_ref().unwrap()[..] {
            return Err(SpRaError::IntegrityError);
        }
        if !msg3.verify_mac(self.smk.as_mut().unwrap()).is_ok() {
            return Err(SpRaError::IntegrityError);
        }
        let quote_digest: Sha256Digest = (&msg3.quote.as_ref()[368..400]).try_into().unwrap();
        //only try to compare 31bytes sha256 result,because the length is only to 64bytes and signer publick key need 33 bytes
        if &self.verification_digest.as_ref().unwrap()[..31] != &quote_digest[..31] {
            return Err(SpRaError::IntegrityError);
        }

        // Verify attestation evidence
        // TODO: use the secondary key as well
        let sy_time = SystemTime::now();
        let attestation_result = self
            .ias_client
            .verify_attestation_evidence(&msg3.quote, &self.config.primary_subscription_key)
            .await?;
        println!(
            "{:?}",
            SystemTime::now()
                .duration_since(sy_time)
                .unwrap()
                .as_micros()
        );

        if cfg!(feature = "verbose") {
            eprintln!("==============Attestation Result==============");
            eprintln!("{:#?}", attestation_result);
            eprintln!("==============================================");
        }

        // Verify enclave identity
        let mrenclave = &msg3.quote[112..144];
        let mrsigner = &msg3.quote[176..208];
        let isvprodid = (&msg3.quote[304..306]).read_u16::<LittleEndian>().unwrap();
        let isvsvn = (&msg3.quote[306..308]).read_u16::<LittleEndian>().unwrap();
        if mrenclave != self.sigstruct.enclavehash.as_ref()
            || mrsigner != sha256(self.sigstruct.modulus.as_ref())?.as_ref()
            || isvprodid != self.sigstruct.isvprodid
            || isvsvn != self.sigstruct.isvsvn
        {
            return Err(SpRaError::SigstructMismatched);
        }

        // Make sure the enclave is not in debug mode in production
        let attribute_flags = &self.sigstruct.attributes.flags;
        if cfg!(not(debug_assertions)) {
            if (&sgx_isa::AttributesFlags::DEBUG).intersects(*attribute_flags) {
                return Err(SpRaError::EnclaveInDebugMode);
            }
        }

        // Decide whether to trust enclave
        let quote_status = attestation_result.isv_enclave_quote_status.clone();
        let pse_manifest_status = attestation_result.pse_manifest_status.clone();
        let is_enclave_trusted = (quote_status == "OK")
            || self
                .config
                .quote_trust_options
                .binary_search(&quote_status)
                .is_ok();
        let is_pse_manifest_trusted = pse_manifest_status.map(|status| {
            (status == "OK")
                || self
                    .config
                    .pse_trust_options
                    .as_ref()
                    .unwrap()
                    .binary_search(&status)
                    .is_ok()
        });

        Ok((
            RaMsg4 {
                is_enclave_trusted,
                is_pse_manifest_trusted,
                pib: attestation_result.platform_info_blob,
            },
            attestation_result.epid_pseudonym,
        ))
    }
}
#[tokio::main]
pub async fn verify_quote(
    mut config: SpConfigs,
    enclave_stream: &mut (impl Read + Write),
) -> SpRaResult<()> {
    config.quote_trust_options.sort();
    config.pse_trust_options.as_mut().map(|v| v.sort());
    let mut rng = Rng::new();
    let mut rand_data = vec![0u8; 64];
    rng.inner.random( &mut rand_data ).expect("error for rand data!");
    enclave_stream.write_all(&rand_data).unwrap();
    let sig_len = enclave_stream.read_u32::<NetworkEndian>().unwrap() as usize;
    // Obtain quote and QE report from client
    let mut quote = [0u8; size_of::<Quote>()];
    enclave_stream.read_exact(&mut quote[..]).unwrap(); 

    let mut rand_sig = vec![0u8; sig_len];
    enclave_stream.read_exact(&mut rand_sig[..]).unwrap();
    let ec_public_key = &mut quote[399..432];
    let mut verify_key = VerificationKey::new_from_binary(&ec_public_key)
    // let mut verify_key = VerificationKey::new(&ec_public_key[..33])
        .expect("get new verify public key failed!");
    verify_key
        .verify(&rand_data, &rand_sig)
        .expect("verify failed!");
    enclave_stream.write_all(&[1u8;4]).unwrap();
    //send quote to intel
    // let configs = parse_config_file("examples/data/settings.json");
    let cert = X509Cert::new_from_pem_file(Path::new(&config.ias_root_cert_pem_path))?;
    let attestation_result = IasClient::new(cert)
        .verify_attestation_evidence(&quote, &config.primary_subscription_key)
        .await?;
    if cfg!(feature = "verbose") {
        eprintln!("==============Attestation Result==============");
        eprintln!("{:#?}", attestation_result);
        eprintln!("==============================================");
    }
    // Decide whether to trust enclave
    let quote_status = attestation_result.isv_enclave_quote_status.clone();
    let pse_manifest_status = attestation_result.pse_manifest_status.clone();
    let is_enclave_trusted = (quote_status == "OK")
        || config
            .quote_trust_options
            .binary_search(&quote_status)
            .is_ok();
    let is_pse_manifest_trusted = pse_manifest_status.map(|status| {
        (status == "OK")
            || config
                .pse_trust_options
                .as_ref()
                .unwrap()
                .binary_search(&status)
                .is_ok()
    });
    if !is_enclave_trusted {
        return Err(SpRaError::EnclaveNotTrusted);
    }
    match is_pse_manifest_trusted {
        Some(t) => {
            if !t {
                return Err(SpRaError::PseNotTrusted);
            }
        }
        None => {}
    }
    Ok(())
}
use crate::SpRaResult;
use http::{HeaderMap, StatusCode};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;

#[derive(Deserialize, Debug, Clone)]
pub struct AttestationInfo {
    pub id: u8,
    pub client_ip: String,
    pub enclave_port: String,
    pub sp_private_key_pem_path: String,
    pub sigstruct_path: String,
}

#[derive(Deserialize, Debug, Clone)]
pub struct SpConfig {
    pub enclave_id: u8,
    pub linkable: bool,
    pub random_nonce: bool,
    pub use_platform_service: bool,
    pub spid: String,
    pub primary_subscription_key: String,
    pub secondary_subscription_key: String,
    pub quote_trust_options: Vec<String>,
    pub pse_trust_options: Option<Vec<String>>,
    pub ias_root_cert_pem_path: String,
    pub sp_private_key_pem_path: String,
    pub sigstruct_path: String,
    pub enclave_port: String,
}

#[derive(Deserialize, Debug, Clone)]
pub struct SpConfigs {
    pub linkable: bool,
    pub random_nonce: bool,
    pub use_platform_service: bool,
    pub spid: String,
    pub primary_subscription_key: String,
    pub secondary_subscription_key: String,
    pub quote_trust_options: Vec<String>,
    pub pse_trust_options: Option<Vec<String>>,
    pub ias_root_cert_pem_path: String,
    pub listener_address: String,
    pub slaves: Vec<AttestationInfo>,
}

impl SpConfigs {
    pub fn generate_spconfig(&self, id: u8, peer_ip: &IpAddr) -> SpRaResult<SpConfig> {
        let mut sp_private_key_pem_path = "".to_string();
        let mut enclave_port = "".to_string();
        let mut exit: bool = false;
        let mut sigstruct_path = "".to_string();
        println!("slave id: {:?} ", id);
        //let id = idstr.parse::<u8>().expect("the input value is invalid,that should be a id and type is \"u8\"");
        for slave in self.slaves.iter() {
            //slaves.push(slave.clone());
            //if slave.client_port.parse::<SocketAddr>()  == Ok(*peer_socket){
            if slave.client_ip.parse::<IpAddr>() == Ok(*peer_ip)
                && "127.0.0.1".parse::<IpAddr>() != Ok(*peer_ip)
            {
                sp_private_key_pem_path = slave.sp_private_key_pem_path.clone();
                sigstruct_path = slave.sigstruct_path.clone();
                enclave_port = slave.enclave_port.clone();
                exit = true;
                break;
            } else if "127.0.0.1".parse::<IpAddr>() == Ok(*peer_ip) && id == slave.id {
                sp_private_key_pem_path = slave.sp_private_key_pem_path.clone();
                sigstruct_path = slave.sigstruct_path.clone();
                enclave_port = slave.enclave_port.clone();
                exit = true;
                break;
            }
        }
        match true == exit {
            true => Ok(SpConfig {
                sp_private_key_pem_path,
                sigstruct_path,
                enclave_port,
                enclave_id: id,
                linkable: self.linkable.clone(),
                random_nonce: self.random_nonce.clone(),
                use_platform_service: self.use_platform_service.clone(),
                spid: self.spid.clone(),
                primary_subscription_key: self.primary_subscription_key.clone(),
                secondary_subscription_key: self.secondary_subscription_key.clone(),
                quote_trust_options: self.quote_trust_options.clone(),
                pse_trust_options: self.pse_trust_options.clone(),
                ias_root_cert_pem_path: self.ias_root_cert_pem_path.clone(),
            }),
            false => Err(super::error::SpRaError::ClientConfigNotFound),
        }
    }

    // pub fn generate_spconfig(&self,peer_ip:& IpAddr) -> SpRaResult<SpConfig> {
    //     let mut sp_private_key_pem_path = "".to_string();
    //     let mut exit: bool = false;
    //     let mut sigstruct_path = "".to_string();
    //     for slave in self.slaves.iter() {
    //         //print!("{:#?} ", slave);
    //         //slaves.push(slave.clone());
    //         //if slave.client_port.parse::<SocketAddr>()  == Ok(*peer_socket){
    //         if slave.client_ip.parse::<IpAddr>()  ==  Ok(*peer_ip){
    //             sp_private_key_pem_path = slave.sp_private_key_pem_path.clone();
    //             sigstruct_path = slave.sigstruct_path.clone();
    //             exit = true;
    //             break;
    //         }
    //     }
}

//send http response with socket
#[derive(Serialize, Deserialize)]
pub struct HttpRespWrap {
    #[serde(with = "http_serde::header_map")]
    pub map: HeaderMap,
    #[serde(with = "http_serde::status_code")]
    pub statu: StatusCode,
}
mod attestation_response;
mod config;
pub mod context;
mod error;
mod ias;

pub use crate::config::*;
pub use crate::context::*;
pub use crate::error::*;

pub type SpRaResult<T> = Result<T, crate::error::SpRaError>;

use sgx_crypto::cmac::MacTag;

pub struct AttestationResult {
    pub epid_pseudonym: Option<String>,
    pub signing_key: MacTag,
    pub master_key: MacTag,
}
#[derive(Debug)]
pub enum SpRaError {
    Crypto(sgx_crypto::error::CryptoError),
    IO(std::io::Error),
    IAS(IasError),
    Serialization(std::boxed::Box<bincode::ErrorKind>),
    IntegrityError,
    SigstructMismatched,
    EnclaveInDebugMode,
    EnclaveNotTrusted,
    ClientConfigNotFound,
    PseNotTrusted
}

impl std::convert::From<std::io::Error> for SpRaError {
    fn from(e: std::io::Error) -> Self {
        Self::IO(e)
    }
}

impl std::convert::From<sgx_crypto::error::CryptoError> for SpRaError {
    fn from(e: sgx_crypto::error::CryptoError) -> Self {
        Self::Crypto(e)
    }
}

impl std::convert::From<IasError> for SpRaError {
    fn from(e: IasError) -> Self {
        Self::IAS(e)
    }
}

impl std::convert::From<std::boxed::Box<bincode::ErrorKind>> for SpRaError {
    fn from(e: std::boxed::Box<bincode::ErrorKind>) -> Self {
        Self::Serialization(e)
    }
}

impl std::fmt::Display for SpRaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(f, "{:?}", self)
    }
}

impl std::error::Error for SpRaError {}

#[derive(Debug)]
pub enum AttestationError {
    Connection(http::StatusCode),
    MismatchedIASRootCertificate,
    InvalidIASCertificate,
    BadSignature,
}

#[derive(Debug)]
pub enum IasError {
    IO(std::io::Error),
    Connection(hyper::error::Error),
    SigRLError(http::StatusCode),
    Attestation(AttestationError),
}

impl std::convert::From<std::io::Error> for IasError {
    fn from(e: std::io::Error) -> Self {
        Self::IO(e)
    }
}

impl std::convert::From<hyper::error::Error> for IasError {
    fn from(e: hyper::error::Error) -> Self {
        Self::Connection(e)
    }
}
use crate::attestation_response::AttestationResponse;
use crate::error::{AttestationError, IasError};
use hyper::body::HttpBody;
use hyper::{client::HttpConnector, Body, Client, Request, Response};
use hyper_tls::HttpsConnector;
use ra_common::msg::{Gid, Quote};
use sgx_crypto::certificate::X509Cert;
use std::io::Write;

const BASE_URI: &str = "https://api.trustedservices.intel.com/sgx/dev";
const SIG_RL_PATH: &str = "/attestation/v3/sigrl/";
const REPORT_PATH: &str = "/attestation/v3/report";

pub struct IasClient {
    https_client: Client<HttpsConnector<HttpConnector>>,
    root_ca_cert: X509Cert,
    pub http_resp: Option<Response<Vec<u8>>>,
}

impl IasClient {
    pub fn new(root_ca_cert: X509Cert) -> Self {
        Self {
            https_client: Client::builder().build::<_, hyper::Body>(HttpsConnector::new()),
            root_ca_cert,
            http_resp: None,
        }
    }

    pub async fn get_sig_rl(
        &self,
        gid: &Gid,
        subscription_key: &str,
    ) -> Result<Option<Vec<u8>>, IasError> {
        let uri = format!(
            "{}{}{:02x}{:02x}{:02x}{:02x}",
            BASE_URI, SIG_RL_PATH, gid[0], gid[1], gid[2], gid[3]
        );
        let req = Request::get(uri)
            .header("Ocp-Apim-Subscription-Key", subscription_key)
            .body(Body::empty())
            .unwrap();
        let mut resp = self.https_client.request(req).await?;
        if resp.status().as_u16() != 200 {
            return Err(IasError::SigRLError(resp.status()));
        }
        if resp.headers().get("content-length").unwrap() == "0" {
            return Ok(None);
        }
        let mut sig_rl = Vec::new();
        while let Some(chunk) = resp.body_mut().data().await {
            sig_rl.write_all(&chunk.unwrap()).unwrap();
        }
        Ok(Some(sig_rl))
    }

    pub async fn verify_attestation_evidence(
        &mut self,
        quote: &Quote,
        subscription_key: &str,
    ) -> Result<AttestationResponse, IasError> {
        let uri = format!("{}{}", BASE_URI, REPORT_PATH);
        if cfg!(feature = "verbose") {
            eprintln!("==============msg3.quote Result==============");
            eprintln!("{:?}", base64::encode(&quote[..432]));
            eprintln!("==============================================");
        }
        let quote_base64 = base64::encode(&quote[..]);
        let body = format!("{{\"isvEnclaveQuote\":\"{}\"}}", quote_base64);
        let req = Request::post(uri)
            .header("Content-type", "application/json")
            .header("Ocp-Apim-Subscription-Key", subscription_key)
            .body(Body::from(body))
            .unwrap();
        let mut resp = self.https_client.request(req).await?;
        if resp.status().as_u16() != 200 {
            return Err(IasError::Attestation(AttestationError::Connection(
                resp.status(),
            )));
        }

        let mut body = Vec::new();
        while let Some(chunk) = resp.body_mut().data().await {
            body.write_all(&chunk.unwrap()).unwrap();
        }
        let body2 = body.clone();
        let attresp = AttestationResponse::from_response(&self.root_ca_cert, resp.headers(), body)
            .map_err(|e| IasError::Attestation(e));
        let (http_parts, _) = resp.into_parts();
        self.http_resp = Some(Response::from_parts(http_parts, body2));
        attresp
    }
}
/* Copyright (c) Fortanix, Inc.
 *
 * Licensed under the GNU General Public License, version 2 <LICENSE-GPL or
 * https://www.gnu.org/licenses/gpl-2.0.html> or the Apache License, Version
 * 2.0 <LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0>, at your
 * option. This file may not be copied, modified, or distributed except
 * according to those terms. */

#![allow(dead_code)]

pub const PEM_KEY: &'static [u8] = b"-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDFjAgmCJUmKAQ/
OAg0MBh3E2+l5asSHdBNmTm0gr3vmnmFcUqlIpUG3BGd85o0c9X5qnxBKJafTJLu
2xRqjx1TMlBdtVpP0CXy5qPYwvO8UWIGyrsniy8GfpDjXGkUFbm91Cw1c/lCD7R1
6lLHK+7Npq9oxpk3KfMHivQorFd31byo0VxZv/sFYViCbDtOYmMifQX/qkqsbvkx
SuPklzpxAxF824mtKMRimwGQbZ4tbLlAFNugO02eV0Hq8xHxfbmNrblSqIy68/Ud
jg4Y9feFi8NVfYg/rsFjuL+Fv/3dLBBhaMffyV9J0eULXgVw5ZXNaQgKb6sSBQqi
U3LftHDTAgMBAAECggEBAKzBKN8Z4lTb6drfRU1eQgbgGGMb1d6h8+fod25EZ5WB
oYPw7zY6Z9j32vAmeFQmeJk9XiwdMptce6ImNFR7k0mOVnmcfr4NaSJiUCbfVgb5
pKAL6l9KeHVVeZ9a0Qmfdi9rvL2CDhiXY1k68ej7onp1qjAWfSagqMeP3LU1Acjo
tYnt42QNa/x4spOCx9EoMuKrEiBNYoll7lW6iuIqTO9Oodkh7ZHVEYNe3y4RHIpj
QmMxVrjt9Pe26cesNajkM2OWMxZW8MEeyL7DqUenxNluRrMG2lP5ZtEBuDFRTWEL
xrh89UQcFN0MZPL+HmMunS+ztu0vOh2UQw8zORSw+AECgYEA/DNK/kTJeRC0N4xh
ErcwTUBx2vtYdD/lWo4dRBanw218mXnzu25l8CjOQm0OircELy/UG0eBGCGXaxhh
H274KQqgM7ibSJHTP2J17wfbS3PxIgF75uf7UNP0M2yX/t2bjgfCsaqNckHBIrxN
Ym/FWUN884zrgapaYtiPzjTUF3MCgYEAyIXyguElCI7iYIN0qreSHvt+2qKyKhVO
6NdPf19ZvhT7vk03P6YXt/VCg+eNDeh5EBwHUWG2JQYznIK2jRLFwoFLdIlIjapq
kG9s2NWQ99HpY0mnhTUFptTEpiuyFDbEyhXhWBja5zOn1ZuqW/V9bgCglGoxOckV
2vGv4YX0KSECgYEA0YUTcnZXItr7vYJESzYhTKyTaieR7tH+iuKx8ZUYvsTA1Qh5
smcfDQv5fzn28MrnEQSdJCSdXRzbHL/eQC0CwaXwPcfKSdnMNEZqT7CpQOALngK5
mrVzFk1f/TDkfXpB9xb/anaUmC2EdIUXjQXqYCQvNG8IYGrUOHZN0jQVV30CgYAV
HW209GpG5WzXBuChHWVol8j60sj5/3ZotEttuSelCWac2lqn/CBhQZU4eIh033bo
CFuI6UYZzfZfU7BPWJu0aJL+eXpHWJuSC/mlN4/lWJg/2UCnmTa4I411hgJheIbu
VLF+6lcao2jX6GVe+5GypKREHI6EbDU98dc4YzeboQKBgF/R6wCxhVt9kqSLYeGq
nGQmHqj2/0m7M9O/QS5a4L/3Oyu5YyNuPR6OBMdjivOdz4RwUi6+o9IEepzmN1cV
okcspBUohwqnqHwvdiQjB+RygIpmnXhchXxRok3wc745S1NBCbAL5V3sa6/61/1C
YLT4mPYORlR4AgzvpNOJiI3T
-----END PRIVATE KEY-----\0";

pub const PEM_CERT_SUBJECT: &'static str = "CN=mbedtls.example";

pub const PEM_CERT: &'static [u8] = b"-----BEGIN CERTIFICATE-----
MIIDCTCCAfGgAwIBAgIJALWh9vlifeRuMA0GCSqGSIb3DQEBCwUAMBoxGDAWBgNV
BAMTD21iZWR0bHMuZXhhbXBsZTAgFw0xODExMjMwNTQ5MTBaGA8yMTAwMDEwMTA1
NDkxMFowGjEYMBYGA1UEAxMPbWJlZHRscy5leGFtcGxlMIIBIjANBgkqhkiG9w0B
AQEFAAOCAQ8AMIIBCgKCAQEAxYwIJgiVJigEPzgINDAYdxNvpeWrEh3QTZk5tIK9
75p5hXFKpSKVBtwRnfOaNHPV+ap8QSiWn0yS7tsUao8dUzJQXbVaT9Al8uaj2MLz
vFFiBsq7J4svBn6Q41xpFBW5vdQsNXP5Qg+0depSxyvuzaavaMaZNynzB4r0KKxX
d9W8qNFcWb/7BWFYgmw7TmJjIn0F/6pKrG75MUrj5Jc6cQMRfNuJrSjEYpsBkG2e
LWy5QBTboDtNnldB6vMR8X25ja25UqiMuvP1HY4OGPX3hYvDVX2IP67BY7i/hb/9
3SwQYWjH38lfSdHlC14FcOWVzWkICm+rEgUKolNy37Rw0wIDAQABo1AwTjAdBgNV
HQ4EFgQUbkS8taBrhQDq7t19qFfRzi8q86kwHwYDVR0jBBgwFoAUbkS8taBrhQDq
7t19qFfRzi8q86kwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAD8JW
PJrqtwaTtmmpFv8Xn8K2Tq7BBKg7ANtEs9Ca2SstR9J0idH8YYq69+CHbihO0cVS
QYgkos9FA7NU8eV8twNBBrgSS30ZkIVRCZn72476lHQTWnctqHTqkNmypt5Bdosr
yC9+dy8UCm9UhjW100vu0Oi++/7LU3GOcEuFX65pz4cjFFRLCKmA0mvSiBV4UwWu
HYDzyrZMYYcIpPBj9S7gvoQDeHrpw7yfA5Of+60cZZjwPY9Ebud5ETWnkFqqcShE
PVTB987Vm6hLu5/oHF+JVW05ZdXID1BZvukBYXnwY9OHvU7fin8N/eT/SBTd2HxO
d1SSYr2U5pj0tNqaDQ==
-----END CERTIFICATE-----\0";

pub const ROOT_CA_CERT_SUBJECT: &'static str = "CN=RootCA";

pub const ROOT_CA_CERT: &'static [u8] = b"-----BEGIN CERTIFICATE-----
MIIE4jCCAsqgAwIBAgIBATANBgkqhkiG9w0BAQsFADARMQ8wDQYDVQQDEwZSb290
Q0EwHhcNMTkwOTA1MTg0NTMyWhcNMjEwMzA1MTg0NTI2WjARMQ8wDQYDVQQDEwZS
b290Q0EwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQD6AOBz7HbIi8w3
Wjjk16oglHRQcICTkvgfl6gbGuSjOoVHmOAn2EWT9AuXtcyNcVFyk90h0dsadqkJ
Enrk3BkTJQmtGW0u5UvcI+famYjZDvYQpGcgXBFmrH7/g/BN4v5VvdrXxUVy6Uyv
Ql60yG7JxlMY8K2OMV13bOpABXhnG/zNr1hCPLQWu52Mn3M1nudFBZff7tZz4dBo
YoMeXkIWQ3t2wypD3WunlQcuGxNOCcXONZRDzeUidh/Yv/4tTggZe8KAnEngKb86
KwKAhVjinGIN2C+ISpKsDurDxhExA2Na6+EbtLEgkI9AeoBz6tIjt/yv/inil+Du
fEDSmG+P97oY1GNcZMkftjjJd0u57YWz0Ck5bfHdgploh/1VHGdoC677MDWJOb31
O3mGdpTiBHP2Gh6Xwm8NuZc+tQSPVr/GaYg7slLBl/7GWU9QGjr9DGj/qYozD8tT
cazIHFh9zDP4XC+a+D+3lMA5EMfvVmDmr2QZJoiKBrxbNXXZ0QQcc+Wr9jFBBx/i
BRlpnxr+EDG+Q7nFnbG6x1DkvKhc1KDGBhq/HDb5bBVSr7Pjl2FMNh8HVX64mDbA
7clQJHa1rIjB+HxtZB5DNKQbRobyrWgkTpi5XHPhMw966zrhBWgOdAh+PSeq9FEf
Y0w328/EBWGqIg3rRMOvDAQpbojNdwIDAQABo0UwQzAOBgNVHQ8BAf8EBAMCAQYw
EgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUiS413SfVRGy7vVwkLIGdDA4y
yoswDQYJKoZIhvcNAQELBQADggIBAHcRzQhesOTpFG4KINJyzZf7a5lrc8kayTaL
lzSXW1pEl3/OFiMvOayjDq+yVAJB+5j3WZu8AOTFuZ4pBjz2I1hdIt5F2asqnVN3
8ymuC7t4gNAQGhWJldnsL58iTYGlxFciiT/8QSHJJjYRkKxyhF08Oj3Zbs13J4xc
ENLmwCZMFait+qm7aX3idnUa1XMGO26ioQOi0uEVqu9N4p62OQKd/76vmnaqmIAw
5s47DaaUi7DeiBguLZrNzfZcJTAHNM5VxCjsXW4PieN6mJhQSar40794n7HLHxtG
Xc5UdxT3nLclEAviDJFubA1N/szWtu4vdfehdAKCXkIjwoUEVEOpPYEeYr27JFlP
kaxezxswwxY2UD0MZq21FhO7SpVQdmmvfoJvjQwIsiyoa9UNzC6mTqsJPjln+2mK
p6WHzX+E6GeA7Ng6CyvJsHRsqbQdJ0OXHm4GIG2Z05r4AgBtvI6hkhSfAotBt3Xi
lo5BEO6SbUnPYo03zD4x/76c4j/uZLYxy2n+Qrlm2KTQIUu7KEsKdUnLAxjWYePH
VxcYz0/9Z5H4OzhW4J1Qd6OBW0dqETLlMJauPX5DV/slyYQQasPStEJGgiDiKG+B
Jpjv6PefPTqZawP6gPoGmhF4UyMRWZ+NgqLft1uXTHhrHdnrZFag1oPLjxWFs5hx
pElsC4v+
-----END CERTIFICATE-----\0";

pub const ROOT_CA_KEY: &'static [u8] = b"-----BEGIN PRIVATE KEY-----
MIIJQwIBADANBgkqhkiG9w0BAQEFAASCCS0wggkpAgEAAoICAQD6AOBz7HbIi8w3
Wjjk16oglHRQcICTkvgfl6gbGuSjOoVHmOAn2EWT9AuXtcyNcVFyk90h0dsadqkJ
Enrk3BkTJQmtGW0u5UvcI+famYjZDvYQpGcgXBFmrH7/g/BN4v5VvdrXxUVy6Uyv
Ql60yG7JxlMY8K2OMV13bOpABXhnG/zNr1hCPLQWu52Mn3M1nudFBZff7tZz4dBo
YoMeXkIWQ3t2wypD3WunlQcuGxNOCcXONZRDzeUidh/Yv/4tTggZe8KAnEngKb86
KwKAhVjinGIN2C+ISpKsDurDxhExA2Na6+EbtLEgkI9AeoBz6tIjt/yv/inil+Du
fEDSmG+P97oY1GNcZMkftjjJd0u57YWz0Ck5bfHdgploh/1VHGdoC677MDWJOb31
O3mGdpTiBHP2Gh6Xwm8NuZc+tQSPVr/GaYg7slLBl/7GWU9QGjr9DGj/qYozD8tT
cazIHFh9zDP4XC+a+D+3lMA5EMfvVmDmr2QZJoiKBrxbNXXZ0QQcc+Wr9jFBBx/i
BRlpnxr+EDG+Q7nFnbG6x1DkvKhc1KDGBhq/HDb5bBVSr7Pjl2FMNh8HVX64mDbA
7clQJHa1rIjB+HxtZB5DNKQbRobyrWgkTpi5XHPhMw966zrhBWgOdAh+PSeq9FEf
Y0w328/EBWGqIg3rRMOvDAQpbojNdwIDAQABAoICAAC3l+09NGoG3KMcAyXE6JwH
UP4aFIRX25ZbnQPW4+kD9fXqnln+6NQv0wiwYNHXDWDCw9OhAnvk8z8vamLVrsy7
QnfYptOHnNwYzkV2Q0o8HMCXeCRDn1koDYU2H65ZhFlCnioYSsa1nJ60Fgl2ubqi
cwKTTiwmQBpjmZhta5cAIY2Ffz9RZULbbuxEWNRCjG9KQNFHoh3a+/oQrkecBZyC
vQvuK2TecbydVNPxB/ElXgflZ3N6V7ntlNHOWzBOFP/dtwUfbabS99V24h70QvkD
cdSQVjKR5DHSKSI+ozX8yIAuRQsLTabGQ2Lv9wZeGhQ4JuVqWTxpKyAEAzuXbFp/
69n4uEABvYsWtQAaF06ZmpA1Ek40o8HynHOJQ+8RjdRflShah/EJLwrwar8ydlAq
6Q9UCH0xvd9USs2KL/XwSPMfKO+2JeDh98wZ4GKGbK/JfYTKxUyLuQNQRiCuuPI0
DP0dot6xNKtyiRvRsI1jrqzy1QvMiCrwAJ70lucc13XLas1nNCQCzZIcbq0L7/OI
qEfW5PUFyLrVfTEZM0EQs8eNw02G1R1XDBYD2hHlhBXgc5FECeM6EPtqxGylM/+m
8Dim5oZsEN/C5e/AgGiiQgoxadmxmZ9m+bfSqv+HAkgtOItBUX8frLqkYe9GL2Pr
qXI40pMCehI+QKB6h0UBAoIBAQD+B3isiDGk4qgkOLQOk4o0EQ2heaX04qyVjqCv
YseJhoKpnj2IimDG5xCA0VddeKJ+xHLVcEwvJgE75v+4khGQ8PSlA5WJXaznrm5I
UZX26DW8wyxjOxoWjFvnPv9NZYl3IWQp1aHimFIDTMtXMjkBbAI1MsX9un48mXqg
DWQt1xCckMH7KaQAjV5QibCsKYKn7vuOxSI5v1C757xK1BarmgRTtKMKO2iq6jOt
XEOcxqwMAhfzGGjotbJaa6QRe8ItUKsSp9txJQLI0r0nLWAt9MW68nkd+kpPGEZg
GAkKiouWdUKVhVPiFsbO0TmxQSgrABQYQkW19+OZwheZIzAhAoIBAQD78Wjo6oSi
jjBrwFgCCPKRvnA2KGPjUnn0q0LI/CQO7pymygTjLnieTo5Q3y1zpki/7dN7ZdC1
PLJk/3QbFblaYrDwA3ZitQoBFw76iswZgMnLJXDWhn8SW4NnyRPn9yP/BhjK4bIs
T1vBtwffNOx6/u1RWVECuPs3rHdyMmWlHpAX4Wn47XLjvNggbQcXtkmOpCBtD/xA
4Tty3Xbju2bmg69BkqbHk9dXvL0NHsarplif+ep5VviZbrJSOFgn4//Will0kWhL
FLiPoi86XXkUUhMQ3e9KTKZqnD7pVlKGBL91GsFKA8fb9dRXx7cx0ozNoGHteixL
9mOEIx3goiqXAoIBAQCqZuSiB7IVgx17PrY52OqqRo44NVwHy04t/MD5JW/oZtyb
X1SzlO+aPUGqx8KtJtEJ7EmDt5LDReEqB6iebQ1vhtL1JlRXEwl7WF0OEfxg5h+2
Ac5yuiCj4396vZ2Qk34E9dc04ON5Fuhc4lS8pynqNEO+39JEg6dOiz3gw1riDRRN
kiUtkB89Z5dOuy5SLn5AnGUOvlpZFmbXxXlfUKnsbqJcbB26LWPm0rfboLqSHgsm
+viJz2QARnHfiblDKRt2PlijaQog+czGXecYsq2D5mAFKcXpQA48xHHg3/6gnZNJ
WFtT5V4BmXm/HkZvCuAhCCpyo3ITwLdiWvptdVdBAoIBADGkKmiiNMoWvCGu/2g/
PRRMcq2pHa1fxdnYmMsjKzOp/kG60mW09V0z20TCBKGh5Pm0MZRBxnK/Z+MQll7z
09akVXqlJAFk7Hi0g2YITRjFUH1vfiE21PjYATdE3mA5SOVp3R60g7fJVyn/F1T6
h5HggwAhWh3wNseMeuiMV4zGTdv2tTuwBZAr2GXjNZ+NckbhveXfXXOnLWB/lHpg
pXDMB48jByuRzL9j19gq9ThDCXlT88g+w7LvpcEfivcpLHKoReH6+JK6nXbnnOii
HEZNuaX8JLb+DVg6Owcc1BvF+bdoMyeTQSDs+g7lsgnmE4o8jK8PAIVjIc6aYLuv
GDcCggEBAIe+FhtHJiCniXZNGuaBjqFHj7iowpdyIfdUsMrZiZThDipaL14x4cQj
b9NLQaiWX6m0Gn26a0PdzFNjE+drSYxSLbFrWIb2BKA/cxiQkSS05ucm3LzrMDEA
ASbWAG9c7uxG8Cbp5blkNy4UxcpeYYKD5WiKKw8ebcIcGicvKTHk5H4PO9l+NSUZ
IcBXXuKr/KWUO35hhNi8lMqTkEVbz1oyIfAO01GRxvnoUJNFvCjYDGSNc9tPVA4b
+IXEsjoyV39WFeIh6daHFfu24ocmHSeKz9oBevx29ooVb8bYN2tnXP8RpH3ER284
4Gumg+HQfB4NgZvp7Yp9m2HLwNImjNg=
-----END PRIVATE KEY-----\0";

pub const EXPIRED_CERT_SUBJECT: &'static str = "CN=ExpiredNode";

pub const EXPIRED_CERT: &'static [u8] = b"-----BEGIN CERTIFICATE-----
MIIEIjCCAgqgAwIBAgIQEp7jjh4EXBbKv6nGmkRH8jANBgkqhkiG9w0BAQsFADAR
MQ8wDQYDVQQDEwZSb290Q0EwHhcNMTkwOTA1MjEwNzQyWhcNMTkwOTA1MjEwODQy
WjAWMRQwEgYDVQQDEwtFeHBpcmVkTm9kZTCCASIwDQYJKoZIhvcNAQEBBQADggEP
ADCCAQoCggEBAOewBNbMSk8Ru6puwowiZtPpEHyIhNfBmPYHMLPciuPNRxajUPDm
0egYk2bHKpXM4AT2o1CHAppZGShUNTy3Hnkbp3Zs3usgrzXyaGWfz4PLPFSIzd0t
ciDdrUGKqqArq+PTqRVtfVpQFX/h1nA2x/1aQmES2Mx4v5vz0K6eMCJjETqSGxWO
ekTMfAsclI3byheyL7A1mXLihBysj/DaclT42qGOxvrWteo3iH+TBFl9pzwVESBV
p5KzVzL0QpEI0eNrkAsMs46HgHgYQeDiM4w5fgGXVphK2oVNfNBWdCjQXr3aq+eL
MEDp2H+LNqzV+6J3e0sLTi6PdukXbqzlyuMCAwEAAaNxMG8wDgYDVR0PAQH/BAQD
AgO4MB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAdBgNVHQ4EFgQURbdm
Cj5LbX98YTpKAwxqWca0dj8wHwYDVR0jBBgwFoAUiS413SfVRGy7vVwkLIGdDA4y
yoswDQYJKoZIhvcNAQELBQADggIBAL2YCL69kSfICx/gRGvQcoChvk5tQ1g8DCpo
JQ0a3GsNW+ACjv/O9CWiYX2mjg/VyO7nMJWDacwVOgr3ckgIwcjpS0MXRDOABcSE
gOxYezgpqEWenYTyNBV/gHkYZcaNXnGp6rCQ6Yz7gIGQ4ExlOEDWwzA7t8PjWCph
jN1+HDUcdJooBr7WyqYuoDYpUTZFZq7chPdYeyXVhhb8A1mMw4MGt/RulrL/hAru
RFvODsq3gdI9XAoollWN1ysdkGqwZrw3TdvFlVCV0MuMS2A2ayveNfjBNVIqfrYu
VK8u2je9c2VIOBxvhD6fGrSNdUDcIfOqG3/bQ81nZ2+MCi1pPPO1gyZzSUg2eRsg
egpasmyFwb84YcUtbZRZFj8lXbiBdbzd+oAmYbw+k3Ki1Efrik7lNG8JDN300Z74
285FYAgtgJzJkClixpQi1AReLAkzNQ2JsNNFBkyRfc8BHEit2iue/QetuEUjv0Vh
WFSG50uK4E2/vRC7eNyQKp2qhcLNwXULVmtwhuyzzG4HzJ6xkko/jbF/wTSFY5py
pWfCK7fWQzgMCbqalMCUsUZsaBNvOIDpA/QZDNVqw/KDlhUSVT+y/rKPwVq/iyjQ
2qQUYwKzYiF2rzeOx3PxlQDKTVA9QDwfFQZb7iu/33n0ahdT2WyeuZ0Cm4Ztqpzb
LigtrEQx
-----END CERTIFICATE-----\0";

pub const EXPIRED_KEY: &'static [u8] = b"-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDnsATWzEpPEbuq
bsKMImbT6RB8iITXwZj2BzCz3IrjzUcWo1Dw5tHoGJNmxyqVzOAE9qNQhwKaWRko
VDU8tx55G6d2bN7rIK818mhln8+DyzxUiM3dLXIg3a1BiqqgK6vj06kVbX1aUBV/
4dZwNsf9WkJhEtjMeL+b89CunjAiYxE6khsVjnpEzHwLHJSN28oXsi+wNZly4oQc
rI/w2nJU+Nqhjsb61rXqN4h/kwRZfac8FREgVaeSs1cy9EKRCNHja5ALDLOOh4B4
GEHg4jOMOX4Bl1aYStqFTXzQVnQo0F692qvnizBA6dh/izas1fuid3tLC04uj3bp
F26s5crjAgMBAAECggEBAKsbqyc77zFgJlojvNij249rlDp01K9HkoE5JDXhjk3Z
YEQOz4tq3OFtrQb91qyVh2kDAfBKFZkKbnMDZeH2V7IXw2DJ3QSHuf68jW9oTGjI
Y0EHXAqaMqylKvy5vXPXbPYwbrKdjzNw67/reWScgKzSyS1KLwUrtE8oDRm5SFFL
svuG3jOiDscXU+WD4fBLECSlZ8gmdHAl8KpQobtylp3s0ApJV9zcwE/yHoafhlr6
/vi5UtLZyE0J3VGYc/5yrPI1Rvv8EO/8g7DCw5yF10AhwO6fuGv0IiuBX2SigNCN
7/Y1DArGoif3hwCUDbsE0SJhsvYYVeUULfRXpJTHj2ECgYEA6fD1g35qvkkObLUw
FLeKuCjCyy9uDlIev6Kk/SEWlCL8ZTo8a59JXYm2mT+shH+o0REQV4BQ6pkRtqev
z/kPBaafIGPwF3S9MnZw0d+3GizbK5Bzj02CI64ZP7W9EzFR212M04Ld1mrl07uf
70dnMUTKy/jThtBSOEJ/d+5BlFMCgYEA/Yiou3AFCgoxGq0orUfVFF4tyVEIeEz8
OujvpoIIu3gjnqBukCceGQEG5/p4MGe+HVsssTmYpKFP80IwPW7WqkrYakBNEcCT
aQ2/eCy+RVSt1rda4sgTYWV5VNNgQ6IDJtTKziuX1cSjIdbVLzrPV9K2s1+tXKLg
SFJkfCfpHTECgYBXF1tvPorimDQEiFeD/uhnstUB64BfWHcWBKjDi6PqNjQcQ1fn
AP/BENmnp6rEEPp6Co445Q46qA2OIFM1a5UKF4O5/TqOoOkmdi1+FHkIB5b4WuiK
euJuAgxoSXJASOYecm9Q9rE7d8Rj1L+vxrdGAkQ1N0cYM0nIpAjsTwie/QKBgQDg
BkI6JXh+b5UGIl2gB6nzbmh8y7p1Omlh0HP6KEp5BGZNAyvO+pGwvGSS1JIhC3pE
zEyIaQFE7zkLFMA1eFv8a1ghQqIW/pgCquA12ythbbqR0MBhRTNCy3xThNc5y82H
IV32oTRv8mnHO+Jx8kBGNO21P+Sax1zw6sTZpBZq8QKBgH5xnIoHv/AxR5wzokBt
C4j3yqL0Gbs+moaswS1UR8XSnKt8TBcXVozCAy12A4qKSjkP7VKPTLeTOZxw0UBe
8CzQYNKoIGy4ayFVi+VKaNCHKvJm0diQkKw5Tz7L5quBBjt8JpmRtNbPsjXiq4Is
y14Xc4kb05mM5M9u685eWefa
-----END PRIVATE KEY-----\0";
use mbedtls::cipher::raw::{Cipher, CipherId, CipherMode};

pub const MAC_LEN: usize = 16;
pub type MacTag = [u8; MAC_LEN];

/// 128-bit AES-CMAC
pub struct Cmac {
    inner: Cipher,
    key: [u8; MAC_LEN],
}

impl Cmac {
    pub fn new(key: &[u8]) -> super::Result<Self> {
        let mut _key = [0u8; MAC_LEN];
        _key.as_mut().clone_from_slice(key);
        Ok(Self {
            inner: Cipher::setup(CipherId::Aes, CipherMode::ECB, (MAC_LEN * 8) as u32)?,
            key: _key,
        })
    }

    pub fn sign(&mut self, data: &[u8]) -> super::Result<MacTag> {
        let mut tag = [0u8; MAC_LEN];
        self.inner.cmac(self.key.as_ref(), data, tag.as_mut())?;
        Ok(tag)
    }

    pub fn sign_len(&mut self, data: &mut [u8], len: usize) -> super::Result<Vec<u8>> {
        let mut tag = [0u8; MAC_LEN];
        let cmac_len = MAC_LEN as usize;
        let mut result = Vec::new();
        let rang = len / cmac_len;
        for _i in 0..rang {
            self.inner.cmac(self.key.as_ref(), data, tag.as_mut())?;
            result.extend_from_slice(&tag);
            self.key[..].clone_from_slice(&tag);
        }
        let fi = len % cmac_len;
        if fi != 0 {
            self.inner.cmac(self.key.as_ref(), data, tag.as_mut())?;
            result.extend_from_slice(&tag[0..fi]);
        }
        Ok(result)
    }

    pub fn verify(&mut self, data: &[u8], tag: &MacTag) -> super::Result<()> {
        let ref_tag = self.sign(data)?;
        match &ref_tag == tag {
            true => Ok(()),
            false => Err(super::error::CryptoError::CmacVerificationError),
        }
    }
}
use mbedtls::hash;

const SHA256DIGEST_LEN: usize = 32;
pub const SHA256_TYPE: hash::Type = hash::Type::Sha256;
pub type Sha256Digest = [u8; SHA256DIGEST_LEN];

pub fn sha256(data: &[u8]) -> super::Result<Sha256Digest> {
    let mut digest = [0u8; SHA256DIGEST_LEN];
    hash::Md::hash(SHA256_TYPE, data, &mut digest[..])?;
    Ok(digest)
}
// pub use mbedtls::rng::EntropyCallback;

#[cfg(not(target_env = "sgx"))]
use std::sync::Arc;

cfg_if::cfg_if! {
    if #[cfg(any(feature = "rdrand", target_env = "sgx"))] {
        pub fn entropy_new() -> mbedtls::rng::Rdseed {
            mbedtls::rng::Rdseed
        }
    } else if #[cfg(feature = "std")] {
        pub fn entropy_new() -> crate::mbedtls::rng::OsEntropy {
            crate::mbedtls::rng::OsEntropy::new()
        }
    } else {
        pub fn entropy_new() -> ! {
            panic!("Unable to run test without entropy source")
        }
    }
}


#[cfg(target_env = "sgx")]
pub struct Rng {
    pub inner: mbedtls::rng::Rdrand,
}

#[cfg(not(target_env = "sgx"))]
pub struct Rng {
    pub inner: mbedtls::rng::CtrDrbg,
}

#[cfg(target_env = "sgx")]
impl Rng {
    pub fn new() -> Self {
        Self {
            inner: mbedtls::rng::Rdrand,
        }
    }
}

#[cfg(not(target_env = "sgx"))]
impl Rng {
    pub fn new() -> Self {
        let entropy = Arc::new(mbedtls::rng::OsEntropy::new());
        Self {
            inner: mbedtls::rng::CtrDrbg::new(entropy, None).unwrap(),
        }
    }
}
pub mod aes_gcm;
pub mod certificate;
pub mod cmac;
pub mod digest;
pub mod error;
pub mod key_exchange;
pub mod random;
pub mod signature;
pub mod tls_psk;
pub mod keys;
pub type Result<T> = std::result::Result<T, error::CryptoError>;

extern crate cfg_if;use std::io;

#[derive(Debug)]
pub enum CryptoError {
    MbedTls(mbedtls::Error),
    Io(io::Error),
    CmacVerificationError,
}

impl std::convert::From<mbedtls::Error> for CryptoError {
    fn from(e: mbedtls::Error) -> Self {
        Self::MbedTls(e)
    }
}

impl std::convert::From<io::Error> for CryptoError {
    fn from(e: io::Error) -> Self {
        Self::Io(e)
    }
}
use super::digest::{sha256, SHA256_TYPE};
use super::random::Rng;
use mbedtls::ecp::{EcGroup, EcPoint};
use mbedtls::pk::{EcGroupId, Pk, ECDSA_MAX_LEN};
use std::fs::File;
use std::io::Read;
use std::path::Path;

pub type ECDSAPublicKey = Vec<u8>;
pub type Signature = Vec<u8>;
const ECGROUP_ID: EcGroupId = EcGroupId::SecP256K1;
pub struct VerificationKey {
    inner: Pk,
}

impl VerificationKey {
    /// Takes both DER and PEM forms of PKCS#1 or PKCS#8 encoded keys.
    /// When calling on PEM-encoded data, key must be NULL-terminated
    pub fn new(public_key: &[u8]) -> super::Result<Self> {
        let inner = Pk::from_public_key(public_key)?;
        Ok(Self { inner })
    }
    pub fn new_from_binary(public_key: &[u8]) -> super::Result<Self> {
        let secp256k1 = EcGroup::new(ECGROUP_ID).unwrap();
        let rec_pt = EcPoint::from_binary(&secp256k1, &public_key).unwrap();
        let inner = Pk::public_from_ec_components(secp256k1, rec_pt).unwrap();
        Ok(Self { inner })
    }

    /// Takes both DER and PEM forms of PKCS#1 or PKCS#8 encoded keys.
    pub fn new_from_file(public_key_path: &Path) -> super::Result<Self> {
        let mut file = File::open(public_key_path)?;
        let mut buf = Vec::new();
        file.read_to_end(&mut buf)?;
        if public_key_path.extension().unwrap() == "pem" {
            buf.push(0);
        }
        Self::new(&buf[..])
    }

    pub fn verify(&mut self, message: &[u8], signature: &[u8]) -> super::Result<()> {
        let hash = sha256(message)?;
        self.inner.verify(SHA256_TYPE, &hash[..], signature)?;
        Ok(())
    }
}

pub struct SigningKey {
    inner: Pk,
}
impl SigningKey {
    /// Takes both DER and PEM forms of PKCS#1 or PKCS#8 encoded keys.
    /// When calling on PEM-encoded data, key must be NULL-terminated
    pub fn new(private_key: &[u8], password: Option<&[u8]>) -> super::Result<Self> {
        let inner = Pk::from_private_key(private_key, password)?;
        Ok(Self { inner })
    }
    pub fn generate_keypair(rng: &mut Rng) -> super::Result<Self> {
        Ok(Self {
            inner: Pk::generate_ec(&mut rng.inner, ECGROUP_ID)?,
        })
    }

    pub fn get_public_key(&self) -> super::Result<ECDSAPublicKey> {
        let ecgroup = self.inner.ec_group()?;
        Ok(self.inner.ec_public()?.to_binary(&ecgroup, true)?)
    }
    /// Takes both DER and PEM forms of PKCS#1 or PKCS#8 encoded keys.
    pub fn new_from_file(private_key_path: &Path, password: Option<&[u8]>) -> super::Result<Self> {
        let mut file = File::open(private_key_path)?;
        let mut buf = Vec::new();
        file.read_to_end(&mut buf)?;
        if private_key_path.extension().unwrap() == "pem" {
            buf.push(0);
        }
        Self::new(&buf[..], password)
    }

    pub fn sign(&mut self, message: &[u8], rng: &mut Rng) -> super::Result<Signature> {
        let hash = sha256(message)?;
        let sig_len = self.inner.rsa_public_modulus()?.byte_length()?;
        let mut signature = vec![0u8; sig_len];
        self.inner
            .sign(SHA256_TYPE, &hash[..], &mut signature[..], &mut rng.inner)?;
        Ok(signature)
    }
    pub fn ecdsa_sign(&mut self, message: &[u8], rng: &mut Rng) -> super::Result<Signature> {
        let hash = sha256(message)?;
        let sig_len = ECDSA_MAX_LEN;
        let mut signature = vec![0u8; sig_len];
        let len = self.inner.sign_deterministic(
            SHA256_TYPE,
            &hash[..],
            &mut signature[..],
            &mut rng.inner,
        )?;
        //Ok(signature)
        Ok(signature[..len].to_vec())
    }
}
use mbedtls::cipher::raw::{Cipher, CipherId, CipherMode, Operation::Encrypt};

pub const MAC_LEN: usize = 16;
pub type MacTag = [u8; MAC_LEN];

/// 256-bit AES-GCM
pub struct AESGCM {
    inner: Cipher,
}

impl AESGCM {
    // default key len == 32 bytes
    pub fn new() -> super::Result<Self> {
        // _key.as_mut().clone_from_slice(key);
        Ok(Self {
            inner: Cipher::setup(CipherId::Aes, CipherMode::GCM, (32 * 8) as u32)?,
        })
    }
    pub fn new_with_key(key: &[u8], key_len: u32) -> super::Result<Self> {
        // _key.as_mut().clone_from_slice(key);
        if key_len != 16 && key_len != 24 && key_len != 32 {
            panic!("error key len for aes gcm mode");
        }
        let mut inner = Cipher::setup(CipherId::Aes, CipherMode::GCM, (key_len * 8) as u32)
            .expect("Cipher::setup error");
        // inner.set_key_and_maybe_iv(key, None)?;
        inner.set_key(Encrypt, key).expect("Cipher::set_key error");
        let iv = [0u8; 16];
        inner.set_iv(&iv).expect("Cipher::set_iv error");
        inner.reset()?;
        Ok(Self { inner })
    }
    pub fn set_key_iv(&mut self, key: &[u8], iv: &[u8]) -> super::Result<()> {
        // self.inner.set_key_and_maybe_iv(key, Some(iv))?;
        self.inner.set_key(Encrypt, key)?;
        self.inner.set_iv(iv)?;
        self.inner.reset()?;
        Ok(())
    }
    pub fn encrypt(
        &mut self,
        plain_text: &[u8],
        cipher_and_tag: &mut [u8],
        tag_len: usize,
    ) -> super::Result<usize> {
        let ad = [0u8, 0, 0, 0];
        // let cipher_and_tag = cipher_text. + &tag;
        let len = self
            .inner
            .encrypt_auth(&ad, plain_text, cipher_and_tag, tag_len)
            .expect("Cipher::encrypt_auth");
        Ok(len)
    }

    pub fn decrypt(
        &mut self,
        cipher_text_and_tag: &[u8],
        plain_text: &mut [u8],
        tag_len: usize,
    ) -> super::Result<usize> {
        let ad = [0u8, 0, 0, 0];
        Ok(self.inner.decrypt_auth(&ad, cipher_text_and_tag, plain_text, tag_len)?)
    }
}
use super::cmac::{Cmac, MAC_LEN};
use super::random::Rng;
use super::signature::{Signature, SigningKey, VerificationKey};
use mbedtls::ecp::EcPoint;
use mbedtls::pk::{EcGroupId, Pk};
use std::io::Write;

const ECGROUP_ID: EcGroupId = EcGroupId::SecP256R1;
const SECRET_SHARE_LEN: usize = 32;
pub type DHKEPublicKey = Vec<u8>;
pub type KDK = [u8; MAC_LEN];

pub struct DHKE {
    inner: Pk,
}

impl DHKE {
    pub fn generate_keypair(rng: &mut Rng) -> super::Result<Self> {
        Ok(Self {
            inner: Pk::generate_ec(&mut (rng.inner), ECGROUP_ID)?,
        })
    }

    pub fn get_public_key(&self) -> super::Result<DHKEPublicKey> {
        let ecgroup = self.inner.ec_group()?;
        Ok(self.inner.ec_public()?.to_binary(&ecgroup, true)?)
    }

    /// RNG is used to implement countermeasures against side-channel attacks. See https://tls.mbed.org/api/ecdh_8h.html#a423fee27a0c8603bba336cbfe6dadcaa
    pub fn derive_key(
        mut self,
        peer_public_key: &DHKEPublicKey,
        rng: &mut Rng,
    ) -> super::Result<KDK> {
        let mut ikm = vec![0; SECRET_SHARE_LEN];
        let ecgroup = self.inner.ec_group()?;
        let peer_public_key = Pk::public_from_ec_components(
            ecgroup.clone(),
            EcPoint::from_binary(&ecgroup, &peer_public_key[..])?,
        )?;
        let len = self
            .inner
            .agree(&peer_public_key, &mut ikm[..], &mut rng.inner)?;
        assert_eq!(len, SECRET_SHARE_LEN);
        let cmac_key = [0u8; MAC_LEN];
        let mut kdf = Cmac::new(&cmac_key[..])?;
        let out = kdf.sign(&ikm[..])?;
        Ok(out)
    }
    /// diff from derive_key, this method can generate any len key for neccessry
    pub fn derive_key_len(
        mut self,
        peer_public_key: &DHKEPublicKey,
        rng: &mut Rng,
        key_len: usize,
    ) -> super::Result<Vec<u8>> {
        let mut ikm = vec![0; SECRET_SHARE_LEN];
        let ecgroup = self.inner.ec_group()?;
        let peer_public_key = Pk::public_from_ec_components(
            ecgroup.clone(),
            EcPoint::from_binary(&ecgroup, &peer_public_key[..])?,
        )?;
        let len = self
            .inner
            .agree(&peer_public_key, &mut ikm[..], &mut rng.inner)?;
        assert_eq!(len, SECRET_SHARE_LEN);
        let cmac_key = [0u8; MAC_LEN];
        let mut kdf = Cmac::new(&cmac_key[..])?;
        let out = kdf.sign_len(&mut ikm[..], key_len)?;
        Ok(out)
    }
}

/// One-way authenticated DHKE. Alice (g_a) verifies and Bob (g_b) signs.
pub struct OneWayAuthenticatedDHKE {
    inner: DHKE,
}

impl OneWayAuthenticatedDHKE {
    pub fn generate_keypair(rng: &mut Rng) -> super::Result<Self> {
        let inner = DHKE::generate_keypair(rng)?;
        Ok(Self { inner })
    }

    pub fn get_public_key(&self) -> super::Result<DHKEPublicKey> {
        self.inner.get_public_key()
    }

    /// Bob signs the (g_b, g_a).
    pub fn sign_and_derive(
        self,
        g_a: &DHKEPublicKey,
        signing_key: &mut SigningKey,
        rng: &mut Rng,
    ) -> super::Result<(KDK, Signature)> {
        // Sign (g_b, g_a) with Bob's signing key
        let mut gb_ga = Vec::new();
        gb_ga.write_all(&self.inner.get_public_key()?).unwrap();
        gb_ga.write_all(g_a).unwrap();
        let sign_gb_ga = signing_key.sign(&gb_ga[..], rng)?;

        // Derive KDK
        let kdk = self.inner.derive_key(g_a, rng)?;
        Ok((kdk, sign_gb_ga))
    }

    /// Alice verifies the (g_b, g_a).
    pub fn verify_and_derive(
        self,
        g_b: &DHKEPublicKey,
        sign_gb_ga: &Signature,
        verification_key: &mut VerificationKey,
        rng: &mut Rng,
    ) -> super::Result<KDK> {
        // Verify (g_b, g_a) with Bob's verification key
        let mut gb_ga = Vec::new();
        gb_ga.write_all(g_b).unwrap();
        gb_ga.write_all(&self.inner.get_public_key()?).unwrap();
        verification_key.verify(&gb_ga[..], &sign_gb_ga[..])?;

        // Derive KDK
        self.inner.derive_key(g_b, rng)
    }
}
use super::digest::{sha256, SHA256_TYPE};
use mbedtls::alloc::{List as MbedtlsList, Box as MbedtlsBox};
use mbedtls::x509::Certificate;
use std::fs::File;
use std::io::Read;
use std::path::Path;

#[derive(Debug)]
pub struct X509Cert {
    inner: MbedtlsBox<Certificate>,
}

impl X509Cert {
    pub fn new_from_der(x509_der: &[u8]) -> super::Result<Self> {
        let inner = Certificate::from_der(x509_der).unwrap();
        Ok(Self { inner })
    }

    /// Input must be NULL-terminated
    pub fn new_from_pem(x509_pem: &[u8]) -> super::Result<Self> {
        let inner = Certificate::from_pem(x509_pem).unwrap();
        Ok(Self { inner })
    }

    pub fn new_from_der_file(x509_der_path: &Path) -> super::Result<Self> {
        let mut file = File::open(x509_der_path)?;
        let mut buf = Vec::new();
        file.read_to_end(&mut buf)?;
        Self::new_from_pem(&buf[..])
    }

    pub fn new_from_pem_file(x509_pem_path: &Path) -> super::Result<Self> {
        let mut file = File::open(x509_pem_path)?;
        let mut buf = Vec::new();
        file.read_to_end(&mut buf)?;
        buf.push(0);
        Self::new_from_pem(&buf[..])
    }

    pub fn verify_this_certificate(&mut self, trust_ca: &mut Self) -> super::Result<()> {
        // self.inner.verify(&mut trust_ca.inner, None)?;
        let mut chain = MbedtlsList::<Certificate>::new();
        chain.push(self.inner.clone());
        let mut ca_chain = MbedtlsList::<Certificate>::new();
        ca_chain.push(trust_ca.inner.clone());
        let err = Certificate::verify(&chain, &mut ca_chain, None);
        match err.as_ref() {
            Err(e) => eprintln!("Certificate verify failed : {:#?} !", e),
            Ok(_v) => eprintln!("Certificate verify successfully !")
        }        
        Ok(())
    }

    pub fn verify_signature(&mut self, message: &[u8], signature: &[u8]) -> super::Result<()> {
        let hash = sha256(message)?;
        self.inner
            .public_key_mut()
            .verify(SHA256_TYPE, &hash[..], signature)?;
        Ok(())
    }
}

impl PartialEq for X509Cert {
    fn eq(&self, other: &Self) -> bool {
        self.inner.as_der() == other.inner.as_der()
    }
}
use mbedtls::ssl::config::{Endpoint, Preset, Transport};
use mbedtls::ssl::{Config, Context, HandshakeContext};
use mbedtls::Result;
use std::sync::Arc;
use super::random::Rng;

type Callback = Box<dyn FnMut(&mut HandshakeContext, &str) -> Result<()>>;

pub mod server {
    use super::*;
    pub fn callback(psk: &[u8]) -> Callback {
        let psk = psk.to_owned();
        Box::new(move |ctx: &mut HandshakeContext, _: &str| ctx.set_psk(psk.as_ref()))
    }

    pub fn config(rng: Rng, callback: &mut Callback) -> Config {
        let mut config = Config::new(Endpoint::Server, Transport::Stream, Preset::Default);
        config.set_rng(Arc::new(rng.inner));
        config.set_psk_callback(callback);
        config
    }

    pub fn context(config: Arc<Config>) -> Context {
        Context::new(config)
    }
}

pub mod client {
    use super::*;

    pub fn config(rng: Rng, psk: &[u8]) -> Result<Config> {
        let mut config = Config::new(Endpoint::Client, Transport::Stream, Preset::Default);
        config.set_rng(Arc::new(rng.inner));
        config.set_psk(psk, "Client_identity")?;
        Ok(config)
    }

    pub fn context(config: Arc<Config>) -> Context {
        Context::new(config)
    }
}
use byteorder::{LittleEndian, WriteBytesExt};
use serde::{Deserialize, Serialize};
use serde_big_array::big_array;
use sgx_crypto::cmac::{Cmac, MacTag};
use sgx_crypto::error::CryptoError;
use sgx_crypto::key_exchange::DHKEPublicKey;
use sgx_crypto::signature::Signature;
use std::io::Write;
use std::mem::size_of;

pub type Gid = [u8; 4];
pub type Spid = [u8; 16];
pub type PsSecPropDesc = [u8; 256];
pub type Quote = [u8; 1116]; // 436 + quote.signature_len for version 2

big_array! {
    BigArray;
    +size_of::<Quote>(),
}

#[derive(Serialize, Deserialize, Debug)]
pub struct RaMsg0 {
    pub exgid: u32,
}

#[derive(Serialize, Deserialize)]
pub struct RaMsg1 {
    pub gid: Gid,
    pub g_a: DHKEPublicKey,
}

#[derive(Serialize, Deserialize)]
pub struct RaMsg2 {
    pub g_b: DHKEPublicKey,
    pub spid: Spid,
    pub quote_type: u16, /* unlinkable Quote(0) or linkable Quote(1) */
    pub sign_gb_ga: Signature,
    pub mac: MacTag,
    pub sig_rl: Option<Vec<u8>>,
}

impl RaMsg2 {
    pub fn new(
        smk: &mut Cmac,
        g_b: DHKEPublicKey,
        spid: Spid,
        quote_type: u16,
        sign_gb_ga: Signature,
        sig_rl: Option<Vec<u8>>,
    ) -> Result<Self, CryptoError> {
        let mut msg2 = Self {
            g_b,
            spid,
            quote_type,
            sign_gb_ga,
            mac: [0u8; size_of::<MacTag>()],
            sig_rl,
        };
        let a = msg2.get_a();
        msg2.mac = smk.sign(&a[..])?;
        Ok(msg2)
    }

    pub fn verify_mac(&self, smk: &mut Cmac) -> Result<(), CryptoError> {
        let a = self.get_a();
        smk.verify(&a[..], &self.mac)
    }

    fn get_a(&self) -> Vec<u8> {
        let mut a = Vec::new();
        a.write_all(&self.g_b[..]).unwrap();
        a.write_all(&self.spid[..]).unwrap();
        a.write_u16::<LittleEndian>(self.quote_type).unwrap();
        a.write_all(&self.sign_gb_ga[..]).unwrap();
        a
    }
}

#[derive(Serialize, Deserialize)]
pub struct PsSecPropDescInternal {
    #[serde(with = "BigArray")]
    pub inner: PsSecPropDesc,
}

#[derive(Serialize, Deserialize)]
pub struct RaMsg3 {
    pub mac: MacTag,
    pub g_a: DHKEPublicKey,
    pub ps_sec_prop: Option<PsSecPropDescInternal>,
    #[serde(with = "BigArray")]
    pub quote: Quote,
}

impl RaMsg3 {
    pub fn new(
        smk: &mut Cmac,
        g_a: DHKEPublicKey,
        ps_sec_prop: Option<PsSecPropDesc>,
        quote: Quote,
    ) -> Result<Self, CryptoError> {
        let ps_sec_prop = ps_sec_prop.map(|v| PsSecPropDescInternal { inner: v });
        let mut msg3 = Self {
            mac: [0u8; size_of::<MacTag>()],
            g_a,
            ps_sec_prop,
            quote,
        };
        let m = msg3.get_m();
        msg3.mac = smk.sign(&m[..])?;
        Ok(msg3)
    }

    pub fn verify_mac(&self, smk: &mut Cmac) -> Result<(), CryptoError> {
        let m = self.get_m();
        smk.verify(&m[..], &self.mac)
    }

    fn get_m(&self) -> Vec<u8> {
        let mut m = Vec::new();
        m.write_all(&self.g_a[..]).unwrap();
        if self.ps_sec_prop.is_some() {
            m.write_all(&self.ps_sec_prop.as_ref().unwrap().inner[..])
                .unwrap();
        }
        m.write_all(&self.quote[..]).unwrap();
        m
    }
}

#[derive(Serialize, Deserialize, Debug)]
pub struct RaMsg4 {
    pub is_enclave_trusted: bool,
    pub is_pse_manifest_trusted: Option<bool>,
    pub pib: Option<String>,
}
pub mod msg;
pub mod tcp;

use sgx_crypto::cmac::{Cmac, MacTag};
use sgx_crypto::error::CryptoError;
/// Derive SMK, SK, MK, and VK according to
/// https://software.intel.com/en-us/articles/code-sample-intel-software-guard-extensions-remote-attestation-end-to-end-example
pub fn derive_secret_keys(kdk: &mut Cmac) -> Result<(MacTag, MacTag, MacTag, MacTag), CryptoError> {
    let smk_data = [0x01, 'S' as u8, 'M' as u8, 'K' as u8, 0x00, 0x80, 0x00];
    let smk = kdk.sign(&smk_data)?;

    let sk_data = [0x01, 'S' as u8, 'K' as u8, 0x00, 0x80, 0x00];
    let sk = kdk.sign(&sk_data)?;

    let mk_data = [0x01, 'M' as u8, 'K' as u8, 0x00, 0x80, 0x00];
    let mk = kdk.sign(&mk_data)?;

    let vk_data = [0x01, 'V' as u8, 'K' as u8, 0x00, 0x80, 0x00];
    let vk = kdk.sign(&vk_data)?;

    Ok((smk, sk, mk, vk))
}
use std::io::{Error, ErrorKind, Result};
use std::net::{TcpListener, TcpStream};
use std::thread::sleep;
use std::time::{Duration, Instant};

const CONNECT_SLEEP_TIME_MILLIS: u64 = 10;

pub fn tcp_connect(addr: &str, timeout: Duration) -> Result<TcpStream> {
    let start = Instant::now();
    loop {
        match TcpStream::connect(addr) {
            Ok(s) => {
                return Ok(s);
            }
            Err(e) => {
                if start.elapsed() == timeout {
                    return Err(Error::new(ErrorKind::TimedOut, e));
                }
            }
        }
        sleep(Duration::from_millis(CONNECT_SLEEP_TIME_MILLIS));
    }
}

pub fn tcp_accept(addr: &str) -> Result<TcpStream> {
    let listener = TcpListener::bind(addr)?;
    Ok(listener.accept()?.0)
}
#### build.sh
TARGET_NAME=sgx-task-enclave
TARGET_DIR=`pwd`/sgx-task-enclave/target/x86_64-fortanix-unknown-sgx/debug
TARGET=$TARGET_DIR/$TARGET_NAME
TARGET_SGX=$TARGET_DIR/$TARGET_NAME.sgxs
TARGET_SIG=$TARGET_DIR/$TARGET_NAME.sig
KEY=ra-enclave/examples/data/vendor-keys/private_key.pem

# Build and sign enclave
(cd sgx-task-enclave && cargo build --target x86_64-fortanix-unknown-sgx ) && \
ftxsgx-elf2sgxs $TARGET --heap-size 0x2000000 --stack-size 0x20000 --threads 8 \
    --debug --output $TARGET_SGX && \
#sgxs-sign --key $KEY $TARGET_SGX $TARGET_DIR/$TARGET_NAME.sig -d --xfrm 7/0 --isvprodid 0 --isvsvn 0
sgxs-sign --key $KEY $TARGET_SGX $TARGET_SIG -d --xfrm 7/0 --isvprodid 0 --isvsvn 0